{"meta":{"title":"Hiko's Blog","subtitle":"Things I Have.","description":"Hikoyan","author":"hiko","url":"http://www.hikoyan.design","root":"/"},"posts":[{"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.hikoyan.design/tags/CSS/"}],"title":"重新学习CSS","text":"CSS#本文为部门内训创建，也希望借此机会重新巩固css相关知识，所谓温故而知新嘛# 目录# 基础回顾 1.从引入css开始 2.选择器 基本规则 3.属性 4.简单的计算函数 5.@rules @import @media @keyframe @supports 6. 速记属性 对于常用的margin padding background 7.css的工作流程 8.使用自定义的字体 9.盒模型基础 边距重叠解决方案(BFC) BFC的原理 怎么创建bfc 应用场景 10.flex 11.head里需要加上的meta（手机端 web学习链接：https://developer.mozilla.org/zh-CN/ 基础回顾#1.从引入css开始#在里添加的语句块 1&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; 其中的rel属性，是让浏览器知道有CSS文档存在（所以需要遵守CSS样式的规定），属性 href 指定，寻找CSS文件的位置。在引入失效时，对应的标签内容会以浏览器的默认样式渲染，也就是原来这个标签是怎样的样式，它就是怎样的样式。 有的时候我们会遇到：引入了cdn的css库文件，但是对应的标签直接消失不见了或是怎么！important这个样式也不能修改，那就应该注意，如果是消失不见了 是原默认样式（或定义的样式）造成的那就不应该怪到库文件上，而没有期望样式同时浏览器请求200时才应该考虑是不是引入文件本身的问题。 2.选择器#如果你的样式没有生效，那很可能是你的选择器没有像你想象的那样选中你想要的元素。 每个CSS规则都以一个选择器或一组选择器为开始，去告诉浏览器这些规则应该应用到哪些元素上。以下都是有效的选择器或组合选择器的示例。通常情况下，两个选择器可以选择相同的HTML元素。 CSS语言有规则来控制在发生碰撞时哪条规则将获胜–这些规则称为级联规则和专用规则。写在靠后的样式将覆盖以前的样式。这就是起作用的级联。 但是，在我们使用类选择器和元素选择器时，类将获胜，即使它出现在样式表的前面。一个类被描述为比元素选择器更具体，或者具有更多的特异性，所以它获胜了。 基本规则#A + B 相邻兄弟节点 A ~ B 兄弟选择符，位置无须紧邻，只须同层级，A~B 选择A元素之后所有同层级B元素 A &gt; B 子选择器 A B（有空格） 后代选择器 :name 伪类 ::伪元素 3.属性#重要的是要记住，在css中，属性和值都是区分大小写的。 如果属性未知或某个值对给定属性无效，则声明被视为无效，并被浏览器的CSS引擎完全忽略。 属性值也可以作为选择器 1[attr] 表示带有以 attr 命名的属性的元素。 1[attr=value] 表示带有以 attr 命名的属性，且属性值为 value 的元素。 1[attr~=value] 表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 value。 1[attr|=value] 表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（”-“为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。 1[attr^=value] 表示带有以 attr 命名的属性，且属性值是以 value 开头的元素。 1[attr$=value] 表示带有以 attr 命名的属性，且属性值是以 value 结尾的元素。 1[attr*=value] 表示带有以 attr 命名的属性，且属性值包含有 value 的元素。 1[*attr* *operator* *value* i] 在属性选择器的右方括号前添加一个用空格隔开的字母 i（或 I），可以在匹配属性值时忽略大小写（支持 ASCII 字符范围之内的字母）。 1[*attr* *operator* *value* s] 在属性选择器的右方括号前添加一个用空格隔开的字母 s（或 S），可以在匹配属性值时区分大小写（支持 ASCII 字符范围之内的字母）。 4.简单的计算函数#calc()函数 例如 1width: calc(90% - 30px); 这里先给了元素90%的宽度 然后再对它减去30px，这里就比较符合设计适配的逻辑，比如一个30% 40% 30%分的页面，中间的div可以先占满40%然后再对应减去设计给的px值，就可以轻松地实现效果图了。 rotate()函数 例如 1transform: rotate(0.8turn)； 当然还有速度模拟的函数 之后一个个慢慢补充上来。 5.@rules# @rules (pronounced “at-rules”). 这是一些特殊的规则 例如，要将额外的样式表导入主CSS样式表，可以使用 @import#1@import &apos;styles2.css&apos;; @media#它可以使用媒体查询来应用css。这里涉及到“媒体查询”，这个概念就是可以缩小小型设备上的字体大小，以纵向模式查看页面时增加段落之间的填充，或者增大触摸屏上按钮的大小，是响应式设计的关键。 举例，比如（官网）先给body元素一个粉红色的背景色。但是，我们随后使用@media创建样式表的一个部分，该部分仅适用于视口大于30em的浏览器。如果浏览器的宽度大于30em，则背景色将为蓝色。 123456789body &#123; background-color: pink;&#125;@media (min-width: 30em) &#123; body &#123; background-color: blue; &#125;&#125; 如果用js 可能就要用到Window.matchMedia()方法或是 MediaQueryList.addListener()监听方法。 @keyframe#这个是在动画序列里用来定义关键帧的，在js中可以通过CSSKeyframesRule这个接口访问，CSSKeyframesRule就是你在css文件中的animation name，“show @keyframe”的show，rulename.appendRule()允许你将新的关键帧规则插入到原有的规则里去，这个用途很广泛。 rulename.deleteRule()，删除对应的动画。 rulename.findRule() 找到对应的动画，如果不存在这样的规则就返回null； @supports#这个就是能让纯css也能模拟js检测的方法了。 123@supports &lt;supports_condition&gt; &#123; /* specific rules */&#125; 其中的condition可以用下列表达式写 1234567891011( transform-origin: 5% 5% )//如果transform-origin的实现语法认为 5% 5%是有效值则为truenot( transform-origin: 10em 10em 10em )//语法不认为10em 10em 10em是有效的.则返回truenot( not( transform-origin: 2px ) )(display: flexbox) and ( not (display: inline-grid) )//not操作符可以应用在任意复杂度的表达式上 如果not操作符位于表达式的最外层,则没有必要使用小括号将它括起来 同时括号的使用有一个独特的地方 包括在if中使用:判断语句也是同样的规则，既几个逻辑与可以并列成为一个表达式,而不需要使用更多的括号: 12345(display: table-cell) and (display: list-item) and (display:run-in)//等价于(display: table-cell) and ((display: list-item) and (display:run-in)) @rules配合伪类就可以实现纯css的“输入检测提示” 样例： 1234567891011//html；&lt;input type=&quot;tel&quot; placeholder=&quot;请输入手机号&quot; required pattern=&quot;\\d&quot;/&gt;&lt;span class=&quot;validity&quot;&gt;&lt;/span&gt;//css:input[type=&quot;tel&quot;]:valid+span:after&#123; content: &apos;✖&apos;; padding-left: 5px; height: 10px; width: 10px;&#125; 6. 速记属性#速记经常允许忽略值（缺省），但它们会将不包含的任何值重置为它们的初始值。这就要确保使用了一组合理的值。 对于常用的margin padding#语法顺序就是上右下左 顺时针，top right bottom left 这个对各种变换也适用 background#1background: color url(image.png) position x y repeat-mode scroll(or fixed or none); 7.css的工作流程# 浏览器载入HTML文件（比如从网络上获取）。 将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。 接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。 浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色）。 总结来说就是浏览器会解析HTML并创造一个DOM，然后解析CSS。对于相同的DOM元素会映射到相同的css，因此共用样式、复用样式的渲染速度、处理效率会比单独选择某个元素更快更高。 当浏览器遇到无法解析的CSS选择器或声明的时候会发生什么呢？ 浏览器什么也不会做，继续解析下一个CSS样式。 相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个CSS选择器。 8.使用自定义的字体#由于设计总是喜欢用一些有趣的字体库来表达设计的趣味性，作为前端我们尽管实现就好了。这里简单介绍一下@font-face的用法。 @font-face CSS at-rule 指定一个用于显示文本的自定义字体；字体能从远程服务器或者用户本地安装的字体加载. 如果提供了local()函数，从用户本地查找指定的字体名称，并且找到了一个匹配项, 本地字体就会被使用. 否则, 字体就会使用url()函数下载的资源。 local()指定查找和使用本地安装的字体名称可以让字体的自定义化程度超过基本字体，同时在不依赖网络情况下实现此功能。 12345@font-face &#123; font-family: &quot;Open Sans&quot;; src: url(&quot;/fonts/OpenSans-Regular-webfont.woff2&quot;) format(&quot;woff2&quot;), url(&quot;/fonts/OpenSans-Regular-webfont.woff&quot;) format(&quot;woff&quot;);&#125; 首先定义一个安全字体 ，然后用src赋值url引入字体文件即可。 在定义使用支持emoji的字体时，也可以通过定义“unicode-range”定义字体范围 9.盒模型基础#边距重叠解决方案(BFC)#首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为“块级格式化上下文” BFC的原理# 内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠。你可以这样理解, 只有一个外边距起作用了. 如果有另外一种场景, 两个元素的外边距长短不一样, 那会是外边距较长的那一个起作用. bfc的区域不会与浮动区域的box重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算 怎么创建bfc# float属性不为none（脱离文档流）如果盒子内的元素是浮动元素且盒子本身不具备 BFC 特性, 那么这个盒子在视觉上并不会包裹住内部浮动元素 position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible 根元素 应用场景# 自适应两栏布局 清除内部浮动 防止垂直margin重叠 10.flex#123456789101112131415161718.flex-test&#123; /* text-align: center; */ text-align:flex; /*父元素常见属性*/ /*设置主轴的方向*/ /*flex-direction： row行,column列*/ /*设置主轴上的子元素排列方式*/ /*justify-content： space-around平分,space-between两边贴中间平分,space-evenly每个间距相同*/ /*设置子元素是否换行*/ /*flex-wrap：wrap/nowrap*/ /*设置侧轴上的子元素排列方式（单行）*/ /*align-items：stretch 拉伸*/ /*设置侧轴上的子元素的排列方式（多行）*/ /*align-content：stretch 子元素高度平分父元素高度*/ /*flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap*/ /*子元素常见属性*/ /*align-self 子元素自己在侧轴的排列方式*/ /*order 属性定义子项的排列顺序(前后顺序) */;&#125; 11.head里需要加上的meta（手机端#12&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=0&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;someting&quot;&gt; web学习链接：#就到此为止，实际演示时已经讲过了的内容就不再赘述了~","permalink":"http://www.hikoyan.design/2020/07/post/","photos":[]},{"tags":[{"name":"Perforce","slug":"Perforce","permalink":"http://www.hikoyan.design/tags/Perforce/"},{"name":"Git","slug":"Git","permalink":"http://www.hikoyan.design/tags/Git/"},{"name":"项目管理","slug":"项目管理","permalink":"http://www.hikoyan.design/tags/项目管理/"},{"name":"美术资源管理","slug":"美术资源管理","permalink":"http://www.hikoyan.design/tags/美术资源管理/"}],"title":"Perforce","text":"[TOC] Perforce 服务端配置 1.安装 1.下载公钥 2.获取公钥的finerprint 3.验证指纹是否与↓匹配 如果是 就说明软件包是可靠的 4.APT（Ubuntu）安装 将Perforce密钥添加到APT密钥环 将Perforce文件夹添加到您的APT配置中。 3.apt更新源 4.安装命令 2.配置 客户端/本地配置 3.分配用户 4.从本地连接到服务器 5.创建Streams_line远程仓库进行项目管理 问题 Perforce#在小组合作时有队员提到了这个perforce(Perforce Helix Core),这是一个类似git的分布式协作/版本控制/应用程序生命周期管理的软件，unity里可以直接在settings里配置并连接到服务器，支持度很高，另外美术资源的更新和同步速度真是非常快，是github比不了的，据说大型代码管理起来速度也非常快？ 总之根据管理手册，我下载了Helix Visual Client（P4V）并在我的服务器上部署了服务端，步骤如下（非常简单 就是按照官网的操作来 服务端配置# 1.安装#指南→https://www.perforce.com/manuals/p4sag/Content/P4SAG/Home-p4sag.html 我选择的安装方式是Linux package-based installation，就是按照服务器的系统版本选择需要的安装包，这里可选的版本如下（指南中有写） 123456789You can install packages for the Perforce service on the following Linux (Intel x86_64) platforms:Ubuntu 12.04 LTS (precise)Ubuntu 14.04 LTS (trusty)Ubuntu 16.04 LTS (xenial)Ubuntu 18.04 LTS (bionic)CentOS or Red Hat 6.xCentOS or Red Hat 7.xSUSE Linux Enterprise Server 12 1.下载公钥# https://package.perforce.com/perforce.pubkey 2.获取公钥的finerprint#1gpg --with-fingerprint perforce.pubkey 3.验证指纹是否与↓匹配 如果是 就说明软件包是可靠的#1E581 31C0 AEA7 B082 C6DC 4C93 7123 CB76 0FF1 8869 4.APT（Ubuntu）安装# 将Perforce密钥添加到APT密钥环#1wget -qO - https://package.perforce.com/perforce.pubkey | sudo apt-key add - 将Perforce文件夹添加到您的APT配置中。#创建一个名为/etc/apt/sources.list.d/perforce.list的文件 1deb http://package.perforce.com/apt/ubuntu &#123;distro&#125; release 这里的{distro}就是填一开始各ubuntu版本对应的软件源了（其实也是版本？其实是没什么差别 ） 3.apt更新源#1apt-get update 4.安装命令#1sudo apt-get install helix-p4d 2.配置#其实就是傻瓜式配置，一开始有队员也用自己服务器配置了下，但是可能不知道怎么分配用户，没办法连上并且合作，于是我谨慎地选择了默认选项（嗯 在一开始时会默认创建一个超级管理员用户，这里建议不适应命令行的可以现在记事本里设置好并保存用户名和密码，然后设置时直接复制上去即可（单击右键 为复制） 其他基本上按enter就行 默认选项即可 unicode模式千万不要开启 123sudo /opt/perforce/sbin/configure-helix-p4d.sh -h或sudo /opt/perforce/sbin/configure-helix-p4d.sh 客户端/本地配置#3.分配用户#之前提到的用户分配问题，其实如果对命令行不熟练的话p4v提供了本地UI界面可视化操作，那么按照文章开头的连接下载cli 在第二步配置的时候有设过一个超级用户，先在p4 admin中按照设定填上。登录后就是这个界面 选中超级用户然后右键，选中new user (这个是快捷操作 可以选择带options的创建方式) 带option的话基本配置最好都不要改（手贱改了一个standard 居然没有写权限 不过可以给策划什么的只需要查看资源的分配这种受限用户），邮箱是必填（不一定要写真实邮箱（在本小团队模拟中 不需要 嗯） 配置好用户名密码然后分发给团队成员就可以协作管理啦 4.从本地连接到服务器# （这个是p4v client 客户端的配置界面） 选择本地的文件夹（可以为空 或有项目）作为workspace，这个workspace之后会映射到远程服务器的depot仓库（就是类似github远程仓一样嘛） 5.创建Streams_line远程仓库进行项目管理#选中depot然后右键创建stream_line远程仓库， 基本配置不用改（咦我好像有改过一个什么选项 忘了 然后我遇到了没法复现创建这个stream line的问题，导致我出现了无法上传unity 的meta文件的问题） 创建好后选择本地workspace的文件 点击ADD 然后submit 就可以看到类似↓的文件目录 程序员哥哥们觉得非常好评hhh，速度非常快，美术资源管理起来也非常容易，再也不用看到svn那个复杂的报错信息和仓库容量爆了的可怕提示了~~ 问题#仍然待解决的是，这里我传输的都是美术资源和说明文档，还没有试过上传代码，不过因为是stream式的仓库，应该不会有问题，创建普通仓库的话遇到了这样的报错↓ （队友遇到的问题↑） 以及我遇到的 文件名报错问题（搜了官方论坛 不过似乎没找到有效的解决方案） 解决方法1：思路就是把这个报错的部分转义掉 1f = filePath.Replace(&quot;@&quot;, &quot;%40&quot;);cmd = new P4Command(p4, &quot;edit&quot;, true, command, changelist.Id.ToString(), f); 查到的相关链接如下，暂时还是没有解决，如果有办法的话欢迎留言~感谢感谢 【1】https://forum.unity.com/threads/packagecache-com-unity-test-framework-1-0-13-cs0246-error.759764/ 【2】https://docs.unity3d.com/Packages/com.unity.test-framework.performance@0.1/manual/index.html 【3】https://stackoverflow.com/questions/37952591/perforce-workaround-to-add-files-with 【4】https://community.perforce.com/s/article/3124 然后队友的方法是去到unity里传 另外 unity 不支持的文件,是不能 从 unity里commit的","permalink":"http://www.hikoyan.design/2020/02/Perforce/","photos":[]},{"tags":[],"title":"HEXO问题一大堆","text":"1 部署后点击阅读下载post的问题 2 typora+picgo failed to fetch 1 部署后点击阅读下载post的问题#问题描述： hexog没问题 hexo d没问题 问题就在网页部署之后可以正常看/archives /tags /categries 但是！不能看各个文章（如果可以 请检查是否是缓存！） 点击文章阅读链接后，发现实际进入链接和正常的（文章永久链接）不一致，是“https://……/post”，在chrome里可能是因为自动识别为源文件链接（hexo s本地预览时），于是给我下载了一堆“post”文件，对没有后缀的那种。 部署后再点击居然就变成了↓ 我觉得应该是yml里root没写对的问题，也可能是之前prettyurl时设置了隐藏后缀.html，网上搜了很久似乎没看到类似问题 检查了配置后康到url后有仓库名 gitee.io/foo 然后root我写的是/这样子会出错，但是我gitee仓库确实有foo的仓库名（导入的github仓嘛），删掉仓库名后恢复正常了，但并没有明白原因2333（反正一定是路由的问题 hexo deploy的部署路由设置有问题（但我明明都设对的？） 2 typora+picgo failed to fetch#这个遇到了发现原先picgo监听的端口被别的占用了于是改了picgo的server，结果typora默认是36677端口，没找到对应配置文件修改，害所以我就把原来占的端口腾出来给picgo了，如果图床设置没问题还报错（包括picgo的js报错，就要考虑是不是两个软件本身配置的问题了）","permalink":"http://www.hikoyan.design/2020/13/question/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"JAVA","slug":"JAVA","permalink":"http://www.hikoyan.design/tags/JAVA/"}],"title":"JAVAEVERYDAY","text":"java是一个纯粹的面向对象的语言 .java文件执行前需要编译为字节码才能运行，和C C++不同的是java文化源代码编译后并不是可以直接在机器上执行的机器码，因此不同平台需要不同平台的编译器，而java则生成的是与平台无关的字节码，需要java虚拟机（JVM） eclipse:https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2019-12/R/eclipse-inst-win64.exe 命令行模式里：在cmd里 javac +*.java 编译 运行：java *(.class) main函数写法形如下↓ 123456public class App&#123; public static(类方法) void main(String args[]) &#123; &#125;&#125; simpleinput 12345678910import java.io.*;public class simpleinput&#123; public static void main(String args[]) throws IOException&#123; String s; BufferedReader ir; ir=new BufferdReader( new InputStreamReader(System.in)); s=ir.readline(); System.out.println(&quot;Input is:&quot;+s); &#125;&#125; 基本类型所指向的内存空间就是他的值， 因此这里y是1 而引用类型，x所指向的是自己的地址（x[]={1,2,3},x=location(eg.010110)),y=x,则y获取的是所指向地址","permalink":"http://www.hikoyan.design/2020/13/post/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.hikoyan.design/tags/计算机网络/"}],"title":"计网笔记*N","text":"[TOC] 计算机网络 中间件 同轴电缆 TPC双绞线 UTP 屏蔽双绞线STP 网屏式双绞线 光纤 选择传输介质 复用技术 频分多路复用FDM 正交FDM (OFDM) 波分多路复用WDM 时分多路复用技术TDM 统计时分多路复用技术STDM 码分多路复用CDMA 第一章习题 计算机网络# 通信原理→网络 概念扩展→ 划重点：自主 独立自主性 资源 资源标识 传输协议 DT设备（自主设备） PSTM公用电话交换网络 中间件#集群|（同种 物理本地） 网格|（异构） 中间件也是一种软件，MID WARE 集群就相当于是同构计算，设备基本相同时就互相连接起来，（刀片计算机) 古建筑未曾布线的建筑内的网络是无线网络，不是移动网络 互通就代表着协议 互操作就代表着理念相通 同轴电缆# TPC双绞线# 双绞线分为非屏蔽和屏蔽 UTP#unshielded twisted pair 水平电缆 用户桌面使用 受绞距影响大 屏蔽双绞线STP#（横切图） 优点就是抗EMI/RFI 干扰 缺点 成本高 安装不易（体积大 双层防护屏蔽 网屏式双绞线#只有一层屏蔽和保护 仍具有抗干扰能力 光纤#作为干线使用 充当垂直电缆 带宽高 距离远 传输快重量轻 无电磁干扰和射频干扰 防窃听 但价格高昂 光纤连接器（光损失10%——20% 机械拼接 特殊的套管夹紧 （光损失10%） 熔合（光纤熔接机）若没有气泡和凹凸 几乎没有任何光损失 单模：8.3/125μm 8.3指的是内径 125指外径（均为直径） 多模 62.5/125μm 选择传输介质# 引导性（有线） 非引导性（无线 ） 复用技术#用在干线上的技术，干线起点如何共用，干线终点如何分离的问题 频分多路复用FDM#在干线起点，信道的频谱被分成若干段（子带），每个用户占据一段来传输自己的信号 正交FDM (OFDM)# 同样的干线可以承载更多的用户，传输效率得到了极大的提升，被广泛使用与802.11 有线电视网络 波分多路复用WDM# 时分多路复用技术TDM# 广泛用于蜂窝网络 统计时分多路复用技术STDM#只在告诉远程通信中使用 不适于用户平均使用信道中 码分多路复用CDMA#允许基站利用整个频段，且无时间限制 每个比特被分为64个或128个 以下哪个不属于PSTN的主要构成？ A.本地回路 B.干线 C.交换局 D.端局 参考答案：D 解析：PSTN三部分分别为：本地回路、干线、交换局 第一章习题#","permalink":"http://www.hikoyan.design/2020/11/post/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.hikoyan.design/tags/操作系统/"}],"title":"操作系统笔记*N","text":"就把这里当做复习营地了 [TOC] 第一章 发展历史 总线（Bus) 用户视图（四层） 操作系统的类型 处理器 中断 中断响应处理与指令执行周期 操作系统内核分类 C/S模型 哑终端&amp;伪终端&amp;虚拟&amp;远程 三类操作系统（分时 实时 批处理 第一章习题 第二章 第一章# 基础之基础图↑ 分层体系结构 其中下面三部分（硬件）属于计算机组成原理的内容 上层使用下层的服务，下层提供上层的服务接口，（通过服务接口调用），服务提供者和服务消费者。 操作系统是唯一的（唯一性），和硬件交互的唯一的软件（在现代操作系统中 为了安全性）就只有操作系统。其他所有软件都不能绕过操作系统。是唯一运行在核心太模式 内核的软件（kernel status) （老师念成了可乐四忒特四） 将复杂硬件调用接口简化、整合、抽象为一个更简单的调用方式（具体的系统抽象化 硬件软件化） 其他软件（包括系统软件 如编译器）则运行在用户太。 系统调用以区别于普通的过程调用 发展历史# 组成原理简图（冯洛伊曼） CPU &amp;memory +I/O 设备 （外存属于I/0) 总线（Bus)# PC指针 program counter 程序计数器，寻址单位是字节，最小单位是比特。Memory是唯一和CPU配合的，CPU不能直接到硬盘（I/O外围存储设备）拉取运行文件，需要先调入内存中。 用户视图（四层）# BIOS（不使用操作系统的软件） 因此没有安装操作系统的计算机系统可以运行程序，有不使用操作系统的软件（嵌入式软件） GUI命令接口 操作系统的类型# 处理器# 中断#中断调用interuput call 重点 过程调用 系统调用system call（internal 中断向量 中断历程 中断嵌套 程序中断是最低等级的 最高等级的 中等的 高的 中断响应处理与指令执行周期# 程序状态字(PSW)是用来控制指令执行顺序并且保留和指示与程序有关的系统状态。一般包括三部分内容：程序基本状态(指令地址、条件码、管目态位等)；中断码；中断屏蔽位，所以选择B、C、D。每个程序都有一个程序状态字，但整个系统设置一个程序状态字寄存器，存放当前正在运行程序的程序状态字。 计算机系统都有自己的指令系统，在多道程序设计系统中，指令系统分为特权指令与非特权指令。特权指令仅能由操作系统使用，如设置时钟、清内存等为特权指令；其他指令为非特权指令，用户只能使用非特权指令。若中央处理机处于目态，仅可以执行非特权指令，在备选答案中，读系统时钟、读用户内存自身数据都属于非特权指令，它们的执行不会构成对系统的破坏，而清除整个内存，则可能造成对系统的破坏，所以在目态下不能执行，只能在管态下执行。 用户与操作系统的接口有：1、程序一级的系统调用；2、命令解释和键盘命令；3、联机或交互式用户的接口；4、脱机或批处理用户的接口E用户内部和外部命令。 操作系统内核分类# C/S模型#微内核↑ 哑终端&amp;伪终端&amp;虚拟&amp;远程#哑终端（早期 任何一个终端要靠主机回显 没有处理能力 只有键盘↑ 伪终端 ←为保证可兼容性 将有处理能力的终端适配哑终端 虚拟终端（图形终端）→有GUI界面 通过软件来模拟终端（没有实际终端 远程终端 telnet SSH 三类操作系统（分时 实时 批处理# What操作系统 特点 批处理系统 适用于计算量大，不需要和用户交互的大型作业。 脱机、多道和成批处理 分时系统 交互性强的多用户系统 多路性、交互性、独占性和及时性 实时系统 事件驱动，较少有人为干预的监督和控制系统 及时性和高可靠性 脱机是指用户脱机使用计算机，即用户提交作业之后直到获得结果之前几乎不再和计算机打交道。 多道是指多道程序运行，即按多道程序设计的调度原则，从一批后备作业中选取多道作业调入内存并组织它们运行； 成批处理是指操作员把用户提交的作业组织成一批，由操作系统负责每批作业间的自动调度。 批处理系统自动化程度比较高，系统吞吐量大，资源利用率高，系统开销小，但各作业周转时间长，不提供用户与系统的交互手段，适合大的成熟的作业。 批处理和分时是以作业为单位进行处理的系统，是一个通用系统。 分时操作系统是一个专用系统，随机处理发生的外部事件，具有实时性、高度的安全可靠性，提供用户有限的人机交互，系统利用率比批处理差。 分时系统中区别于批处理系统的是，作业不应该先进入磁盘，再调入内存。而应该直接进入内存。其次，批处理系统中为一个作业长期占用处理机，直至它运行结束或者是出现I/O请求时，方才用处理机来处理其他作业，从而调度其他作业运行 多路性是指一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机； 交互性是指用户的操作方式是联机方式，即用户通过终端采用人-机会话的方式直接控制程序运行，同程序进行交互； 独占性是指由于系统采用时间片轮转的办法使一台计算机同时为许多终端用户服务，因此客观效果是这些用户彼此间都感觉不到别人也在使用这台计算机，好像只有自己独占计算机一样； 及时性是指用户请求能在很短时间内获得响应。 实时系统的及时性是指系统能及时响应外部事件的请求，并在规定时间内完成对该事件的处理； 高可靠性是指系统本身要安全可靠，因为像生产过程的实时控制、航空订票等实时事务系统，信息处理的延误或丢失往往会带来不堪设想的后果。 实时系统虽然也需要交互性，但是实时系统中，人与系统的交互仅限于访问系统中某些特定的专用服务程序。而分时系统能够向终端用户提供数据处理和资源共享等服务。 可靠性：实时系统中要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失。实时系统中往往采用多级容错机制来保障系统的安全性及数据的安全性。 因此可靠性：实时系统&gt;分时系统。 第一章习题#1.操作系统的两大主要作用是什么 一是作为扩展机器为用户与底层硬件交互提供可扩展的抽象，二是作为资源管理者，为应用程序提供基本的资源集的清晰抽象 （另一种说法：操作系统给用户提供了一个可扩展的机器。个人理解是通过对底层的抽象，对外提供各种接口支持扩展） 2.管理各种软硬件资源 2.分时系统和多道程序系统的区别是什么 在分时系统中，多个用户可以使用他们自己的终端同时访问和执行计算系统上的计算。 多道程序设计系统允许用户同时运行多个程序。 所有分时系统都是多道程序设计系统，但并非所有多道程序设计系统都是分时系统，因为多道程序设计系统可以在只有一个用户的PC上运行。 10.内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助。 大多数现代CPU提供两种执行模式：内核态和用户态。管态下可以执行其指令集中的每条指令，并使用硬件的各种功能。 但是用户态只能执行部分指令，执行时仅使用部分功能。 拥有两种模式允许设计人员以用户态运行用户程序，从而拒绝他们访问关键指令。 12、下面ACD条指令只能在内核态使用 a 禁止所有的中断 b 读日期-时间时钟 c 设置日期-时间时钟 d 改变存储器映像 13、考虑一个有两个CPU的系统，且每一个CPU有两个线程（超线程）。假设有三个程序P0、P1、P2，分别以运行时间5ms, 10ms,20ms开始，运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻赛，并且一旦设定就不改变CPU。 答： 完成这些程序的执行可能需要20,25或30毫秒，具体取决于操作系统如何安排它们。 如果P0和P1在同一个CPU上进行调度，而P2在另一个CPU上进行调度，则需要20毫秒。 如果P0和P2安排在同一个CPU上并且P1安排在另一个CPU上，则需要25毫秒。 如果P1和P2安排在同一个CPU上并且P0安排在另一个CPU上，则需要30毫秒。 如果所有三个都在同一个CPU上，则需要35毫秒。 14、一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns, 这台机器每秒可执行多少条指令？ 答：每一纳秒的指令都从管道中出现。 这意味着机器每秒执行10亿条指令。 根本没关系管道有多少个阶段。 每级1 nsec的10级流水线每秒也会执行10亿条指令。 重要的是完成的指令弹出管道末端的频率。 15.假设一个计算机系统有高速缓存、内存以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns, 内存需要10ns, 磁盘需要10ms。如果缓存命中率是95%， 内存的是99%（缓存失效时），读取一个词的平均时间是多少？ 平均时间 就是各种可能性的加权平均， 123456平均访问时间=95% * 1ns +99%* (1-95%) * 10ns + (1 - 95%) * (1 - 99%) * 10ms0.95×1 nsec（词在缓存中）+ 0.05×0.99×10 nsec（词在RAM中，但不在缓存中）+ 0.05×0.01×10,000,000 nsec（仅限磁盘上的词） = 5001.445纳秒 =5.001445μsec 缓存命中读缓存缓存不命中尝试读内存 内存命中读内存内存还不命中就只能读磁盘了 翻译可能不太好 但是中文语境都是这样的实际上每一层都是一个缓存 内存是一层缓存 cache又是一层靠近cpu的缓存 每往上一级速度快一或多个数量级 最靠近cpu的有三层cache 是在cpu内部的然后是memory 也就是平常说的内存最后是磁盘disk 虽然最慢但是写入以后不会丢失前面几个一旦断电了就全没了 比如磁盘有数据 1234567我在内存放了12345缓存里面又有内存的123 那我123只要读缓存45读内存67就只能去磁盘读 16.在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？【这个传送完成似乎是翻译的锅 “写完数据”？】 如果调用者取回控制，并且在最终发生写操作时立即重写数据，将会写入错误的数据。然而，如果驱动程序在返回之前首先复制将数据复制到一个专用的缓冲器，那么调用者可以立即继续执行。另一个可能性是允许调用者继续，并且在缓冲器可以再用时给它一个信号，但是这需要很髙的技巧，而且容易出错。 我的理解就是：参考教科书的上图。意思是 本来 调用者已经在执行写的指令了 然后被阻塞的因为要等系统把数据写进去，然后调用者突然改了数据？缓冲区的数据就丢失了源，在进行从缓冲区复制到文件的写过程中系统就会报错，因为数据丢失了？这时就必须要阻塞不然就会出错。如果不阻塞就应该是把之前的数据复制到另一个专用的缓冲区，调用者就不需要被阻塞可以继续修改用户缓冲区的数据，或是将缓冲区分成两部分一部分给调用者，当执行指令时把调用者阻塞 把这部分的数据复制到当前缓冲区的另一部分，复制完成后提示调用者就可以不被阻塞继续操作，系统将另一部分的数据继续复制写入文件。 17.什么是陷阱指令？在操作系统中他的用途。 陷阱指令将一个处理器的执行模式从用户模式切换到内核模式。该指令允许用户程序调用操作系统内核中的函数。 18.分时系统中为什么需要进程表？在只有一个进程存在的计算机中，需要进程表吗？ 进程表是为了存储当前被挂起、甚或是被延迟和阻塞的进程状态。在单一进程的系统中是不需要，因为单一进程从不挂起。 书上提到的是多道程序系统 （分时系统都是多道程序设计系统），操作系统周期性地挂起一个进程，然后在这个进程再次启动时为了让其启动时的状态和先前暂停时完全相同，就意味着该进程的所有信息都要保存下来（比如指向某文件的指针），这些所有信息（除了该进程本身的地址空间内容以外）都会被存放在操作系统的进程表里（表本身是数组或链表结构 23.有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用：lseek(fd, 3, SEEK_SET);read(fd, &amp;buffer, 4);其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？ lseek的三个参数含义是，1 文件的描述符，2 文件位置，3 该文件位置相对于文件的起始位置还是 当前位置还是结尾，修改指针后lseek返回文件中的绝对位置。 fd = open(file,how,…) read(fd 指定文件,buffer 指向缓冲区,nbytes说明要读出的字节数) 答案就是：根据这个buffer所指向的就是缓冲区中（刚刚lseek的数据 相对于起始位置的第四个字节） 然后读出4个字节，1,5,9,2 24.假设一个10MB的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是100MB/s。 答：找到文件需要的时间=1 50 ms (移动到50轨道号的时间) + 5 ms (旋转到文件开始部分存储在的扇区的时间) + 10/100 1000 ms (读取10MB的时间) = 155 ms 25.块特殊文件和字符特殊文件的基本差别是什么？ 答：块特殊文件包含被编号的块，每一块都可以独立地读取或者写入。而且可以定位于任何块，并且开始读出或写入。这些对于字符特殊文件是不可能的。 26.在图1-7的例子中库调用称为read，而系统调用自身称为read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？ 系统调用实际上并没有名称，除了在文件中这样描述之外。当库例程read陷入内核时，它将系统调用号码放入寄存器或者堆栈中。该号码通常用于一张表的索引。这里确实没有使用任何名称。而另一方面，库例程的名称是十分重要的，因为它将用于程序中。 27、现代操作系统将进程的地址空间从机器物理内存中分离出来，列举这种设计的两个好处。 这允许可执行程序在不同的运行中 加载到机器内存的不同部分。 此外，它还使程序大小可以超过机器内存的大小（虚拟内存）。 28、对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？ 答：就程序逻辑而言，库例程调用哪个系统调用是没有关系的。但是，如果需要考虑性能问题，无需系统调用就可以完成的任务将使程序运行更快。所有的系统调用都会导致用户环境和内核环境的切换开销。更进一步，在多用户系统中，在系统调用完成之前，操作系统可能调度到其他的进程，这将使得调用过程的处理更加迟缓。 29、图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API，对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？ 答：某些 UNIX调用没有相应的Win32 API: Link: Win32程序不能给文件另外一个名称，或者使某个文件出现在多个目录中。同时，试图创建链接可以便于测试，并且在文件上加锁。 Mount和umount: Wmdows程序不能创建关于标准的路径的假定命名，因为具有多个磁盘驱动器的系统上路径名，其驱动器部分是不同的。 Chmod: Windows程序员不得不假定所有的用户都能访问每个文件。 Kill: Windows程序员不能kill行为失常的程序。 30、可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个髙度可移植的操作系统时你设计的高级的两层是什么样的。 答：每一个系统体系结构都有它自己可以执行的一套指令。因此，奔腾不能执行SPARC程序或者SPARC无法执行奔腾程序。另外，不同的架构使用不同的总线架构（如VME总线，ISA，PCI，MCA，SBU，…）以及CPU的字长（通常是32或64位）。由于硬件上的这些差异，建立一个完全可移植的操作系统是不可行的。一个高度可移植的操作系统将包括两个高级层——一个机器相关层和一个机器独立层。机器相关层屏蔽硬件的细节，必须为每一个架构单独实现，该层提供了一个统一的接口。机器独立层只需要实现一次。为了实现高度可移植，机器相关层应尽可能小 31、请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。 答：策略和机制的分离，使操作系统的设计人员在内核中实现了少量的基本原语。这些原语被简化，因为它们不依赖于任何特定的策略。然后，它们在用户级别可以被用来实现更复杂的机制和策略。 第二章# 进程是以时间为单位的，它是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。进程是操作系统进行资源分配和调度的一个独立单位。快照：一个进程时刻的状态描述信息，（包括五个实体部分分别是P （OS管理运行程序的）数据结构，C（运行程序的）内存代码，D（运行程序的）内存数据，R（运行程序的）通用寄存器信息，PSW（OS控制程序执行的）程序状态字信息。 程序·静态性 等待态（waiting broke)＝阻塞态 纯代码是相对代码+数据而言的，比如同时打开的两个文本文件 系统实际上是开了两个进程 分别处理这两个文件，但是这两个进程 底层在代码层面是共享的，因为操作文件实际上是通过操作系统对磁盘IO进行操作 底层看来和编辑器无关","permalink":"http://www.hikoyan.design/2020/09/post/","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"http://www.hikoyan.design/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"http://www.hikoyan.design/tags/建模/"}],"title":"blender 学习（2）","text":"https://www.51sjsj.com/play.html?courseId=1617&amp;lessonId=23792 设计师之家的blender搬运视频教程 记一下自己每天的笔记，昨天尝试了基本操作，仍然有很多生硬的操作。#看了视频以后发现，blender的选中物体（整个物体）时用的右键MRB，全选也不是ctrl+A而是A，这些操作的理由都非常清晰，不得不说开源的话建模发展不是一般的快，而且顺应程序和交互的逻辑。A的操作类似一个全选开关，如果按下A，所有的选中状态就从on/off切换了。 B是开启十字瞄准，按住左键MLB拖动就可以选中所有框选的物体（基本和其他软件一致），按住中键MMB拖动–减选，而右键此时的操作则是取消（事实上任何时候取消一个工具的操作都可以按MRB） C是开启笔刷刷选（其他软件可能是画圆），滚轴可以缩放笔刷的半径， G对应（grab抓取）移动，这也是Move并不是M的原因，移动本来是要根据三轴移动的，不过自由摆放就更像抓取？2333 按下G以后边线会变成高亮的白色（不是橙色） R对应rotate旋转，（按两下R是自由旋转）S对应scale，加alt还原到初始的变换。 MLB确认 MRB取消不过这些变换操作基本，上是根据视平面的（当前的平面方向），结合 X Y Z变化视平面就可以更自由地变换了 shift+a是个快捷菜单 可以添加物体，之前说的3d游标就作为物体的出生点 按下T就可以看见create分栏，选择更多物体 H（hide)隐藏模型，alt+H还原（所有隐藏物体），如果想特定显示某个隐藏了的物体就到菜单的层次里点那个眼睛（类似ps的图层操作吧）alt+H有时也只显示当前图层的物体 M move layer+数字键（不能是数字键盘） 把物体移到第n个图层这个操作有点麻烦（文字写出来的话） tab进入编辑模式。Nurbs模型和 UV模型，一个是表面网格一个是网格模型（常规的多边形网格模型 如果光滑着色的话两个看起来非常像），而Nurbs是由数学等式和方程生成的，操作比较有限，但十分光滑。 UV+渲染输出#嘛在掌握基础操作以后制作UV就容易多了，2.8+版本里的uv editor 和texture界面都比较清楚，按U（按住是智能UV展开）可以展开UV并在editor里制作UV分布图。注意的是如果直接按A会选中所有的面，一次性展开的话如果你的模型各个方向上的面选起来比较麻烦的话，所有UV都叠在一起你会很难去到PS里绘制，所以建议手动选面（不依靠插件什么的话）然后分好组按U展开（比如我要做的是柱体的话 可能会是按视图展开，也可以柱体展开）。 展开完成后A全选UV布局 选择那个小菜单栏里的“UV”，可以并排减少冗余（如果你的UV都很大 亲这边建议手动缩放）） 导出到PS就可以开始绘制啦，绘制完后再UV那导入图像 切到texture新建一个材质并在颜色后面那个小点上选择（对那个点是可以展开菜单的，哇就是因为这个我还特地去翻手册 总感觉没有一点提示 UI做的一般般（swtcl）可以选择你刚刚导入的图像纹理，然后选择预览渲染效果，贴图就贴上了。 调好灯光什么的 包括节点（其实创建的时候 选择使用节点就会在shading那里有了 同步可以编辑的） 选择渲染导出（渲染图像 查看渲染结果英文对应 recent result 所以如果发现图像没变不用焦急哈） 相机大小可以直接在右侧编辑器里改数值 建议不要动侧边 小字工具的x y比例 那个会压扁图像的。 今日成果 12v北浮电池一个~#","permalink":"http://www.hikoyan.design/2020/06/post/","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"http://www.hikoyan.design/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"http://www.hikoyan.design/tags/建模/"}],"title":"blender学习之路","text":"从如何编辑开始# 其实掌握一门建模软件并不是难事，都是对一个应用的熟悉到熟练的过程吧（虽然我可能没资格说这话） blender的三种编辑模式比较不一样（有可能是因为我建模入门是从最简单的SU开始的，对这个有些膈应） https://docs.blender.org/manual/zh-hans/2.80/modeling/meshes/structure.html blender的中文手册 感谢翻译~ 三个(三角面)，四个(四边面)或更多(n边面)顶点之间的区域定义为面，每侧都有一条边，通常缩写为 tris，quads ＆ n-gons。 三角形总是平坦的，因此易于计算。另一方面，四边形 “利于形变”，因此常用于动画和细分建模。 网格是3D场景中使用的常见物体类型。Blender配有一些 “基本” 网格形状，用户可以之为起点开始建模。编辑模式下，可以在3D游标位置添加基本体。 这个3D游标一开始使用起来真的很苦恼，尤其是Move的快捷键是G ，我实在不明白为什么是G 而且考虑到快捷键M应该有对应的了（有些教程也不改快捷键）所以就也没有去自定义。 重要的是blender建模有三种模式，热键分别对应1,2,3（shift多选 ctrl缩减或扩展选择),这个和其他的类似但是实际操作起来有点累（swtcl) 顶点模式下顶点会被显示为点。选中的顶点显示为橙色，未选中的顶点显示为黑色，当前活动的顶点或最后选择的顶点显示为白色。 边模式下顶点不显示。 不同的是，选中的边显示为橙色，未选中的边显示为黑色，当前活动的边或最后选择的边显示为白色。 面模式 面将伴随着一个用于对面进行选择的选择点在其中央进行显示。 选中的面及其选择点显示为橙色，未选中的面显示为黑色，当前激活的面或最后选择的面呈现白色高亮状态。 对我来说面模式是最接近SU操作的一个了 所以我经常在边模式和面模式中反复切换（ 按下dele键的时候可以选择删除的内容（还有其他操作） 刷选前在右侧属性设置好刷子的半径 配合shift ctrl就可以快速选面了 加/减选 扩展选区 Ctrl-数字键盘+ 扩展到当前选择模式下与选中区域相连的区域。 缩减选区 Ctrl-数字键盘- 从当前选择模式下选中区域相连的部分缩减选择。 下一活动元素 Shift-Ctrl-数字键盘+ 该功能利用了选择历史来基于环绕拓扑对下一个顶点、边、面进行选择。 上一活动元素 Shift-Ctrl-数字键盘- 选择前一活动元素并取消对最后选择元素的选择状态。","permalink":"http://www.hikoyan.design/2020/05/post/","photos":[]},{"tags":[{"name":"Git","slug":"Git","permalink":"http://www.hikoyan.design/tags/Git/"},{"name":"MySql","slug":"MySql","permalink":"http://www.hikoyan.design/tags/MySql/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.hikoyan.design/tags/Ubuntu/"}],"title":"这就是个笔记汇总啦","text":"[TOC] Ubuntu指令 LIst 常用指令 Notes 常用 Git 命令 1.新建代码库 2.配置 3.增删改 4.分支 5.标签tag 6.变化历史查询 MYSQL 创建数据库 4.2 显示数据库 4.3 删除数据库 4.4 连接数据库 4.5 当前选择的数据库 5.1 创建数据表 5.3 删除数据表 5.4 表插入数据 5.5 查询表中的数据 5.6 删除表中数据 5.7 修改表中数据 5.8 增加字段 5.9 修改表名 6、备份数据库 7.1 一个建库和建表的实例1 7.2 一个建库和建表的实例2 Ubuntu指令 LIst#常用指令#1234567891011121314151617181920212223pwd 当前工作目录 pwdls 当前目录内容(list) lsmkdir 创建目录(makedir) mkdir bookscd 进入目录 cd bookstouch 生成空文件 touch book.txtecho 带内容的文件 echo &quot;内容&quot; &gt; book.txtcp 拷贝文件（copy） cp book.txt book.txt.bakrm 删除文件（remove） rm -r（删除所有文件）/-f（强制删除） book.txtrm -rf +foldername 删除文件夹 rmdir 删除空目录 rmdir 空目录mv 移动文件（move） mv 原文件 目标位置mv 重命名 mv a.txt b.txtfind 查找文件 find [指定目录] -name 文件名grep 查找指定文件里的内容 grep &quot;是否有包含内容&quot; book.txtwc 统计文本的行数字符数 wc book.txttree 树状目录 treeln 建立软链接（link） ln -s 目标目录 链接目录（快捷方式）cat 查看文件内容 cat book.txtmore 分页显示文件内容less 分页显示文件内容head 显示文本开头内容tail 显示文件内容结尾内容vim编辑器： ：wq保存并退出 ：q直接退出 ：/搜索+要搜寻的字符串 （按n 下一个匹配的字符 Notes#-s 是代号（symbolic）的意思 ln命令会保持每一处链接文件的同步性——不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接和硬链接两种，软链接就是ln –s 它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。 将档案 yy 产生一个 symbolic link : zz ln -s yy zz 文件夹建立软链接（用绝对地址） ln -s 源地址 目的地 常用 Git 命令#1.新建代码库#12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.配置# 12345678910&gt; # 显示当前的Git配置&gt; $ git config --list&gt; &gt; # 编辑Git配置文件&gt; $ git config -e [--global]&gt; &gt; # 设置提交代码时的用户信息&gt; $ git config [--global] user.name \"[name]\"&gt; $ git config [--global] user.email \"[email address]\"&gt; 3.增删改#123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 4.分支#123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 5.标签tag#1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 6.变化历史查询#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git fetch origin git reset –hard MYSQL 创建数据库#注意：创建数据库之前要先连接Mysql服务器 命令：create database &lt;数据库名&gt; 例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb; 例2：创建数据库并分配用户 ①CREATE DATABASE 数据库名; ②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’; ③SET PASSWORD FOR ‘数据库名‘@’localhost’ = OLD_PASSWORD(‘密码’); 依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。 4.2 显示数据库#命令：show databases （注意：最后有个s）mysql&gt; show databases; 注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明： 1、修改MYSQL的配置文件：my.ini里面修改default-character-set=gbk2、代码运行时修改： ①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk ②PHP代码：header(“Content-Type:text/html;charset=gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL mysql, char csname)；该函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。 4.3 删除数据库#命令：drop database &lt;数据库名&gt;例如：删除名为 xhkdb的数据库mysql&gt; drop database xhkdb; 例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist​ //发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec) 4.4 连接数据库#命令： use &lt;数据库名&gt; 例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb;屏幕提示：Database changed use 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor​ -&gt; WHERE author.editor_id = db2.editor.editor_id; USE语句被设立出来，用于与Sybase相兼容。 有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。 4.5 当前选择的数据库#命令：mysql&gt; select database(); MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？ 1.显示MYSQL的版本mysql&gt; select version();+———————–+| version() |+———————–+| 6.0.4-alpha-community |+———————–+1 row in set (0.02 sec) 显示当前时间mysql&gt; select now();+———————+| now() |+———————+| 2009-09-15 22:35:32 |+———————+1 row in set (0.04 sec) 显示年月日SELECT DAYOFMONTH(CURRENT_DATE);+————————–+| DAYOFMONTH(CURRENT_DATE) |+————————–+| 15 |+————————–+1 row in set (0.01 sec) SELECT MONTH(CURRENT_DATE);+———————+| MONTH(CURRENT_DATE) |+———————+| 9 |+———————+1 row in set (0.00 sec) SELECT YEAR(CURRENT_DATE);+——————–+| YEAR(CURRENT_DATE) |+——————–+| 2009 |+——————–+1 row in set (0.00 sec) 显示字符串mysql&gt; SELECT “welecome to my blog!”;+———————-+| welecome to my blog! |+———————-+| welecome to my blog! |+———————-+1 row in set (0.00 sec) 当计算器用select ((4 4) / 10 ) + 25;+———————-+| ((4 4) / 10 ) + 25 |+———————-+| 26.60 |+———————-+1 row in set (0.00 sec) 串接字符串select CONCAT(f_name, “ “, l_name)AS Namefrom employee_datawhere title = ‘Marketing Executive’;+—————+| Name |+—————+| Monica Sehgal || Hal Simlai || Joseph Irvine |+—————+3 rows in set (0.00 sec)注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列’CONCAT(f_name, “ “, l_name)’起了个假名。 5.1 创建数据表#命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 例如，建立一个名为MyClass的表， 字段名 数字类型 数据宽度 是否为空 是否主键 自动增加 默认值 id int 4 否 primary key auto_increment name char 20 否 sex int 4 否 0 degree double 16 是 mysql&gt; create table MyClass( > id int(4) not null primary key auto_increment , > name char(20) not null, > sex int(4) not null default ‘0’, > degree double(16,2)); 5.3 删除数据表#命令：drop table &lt;表名&gt; 例如：删除表名为 MyClass 的表 mysql&gt; drop table MyClass; DROP TABLE用于取消一个或多个表。您必须有每个表的DROP权限。所有的表数据和表定义会被取消，所以使用本语句要小心！ 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 RESTRICT和CASCADE可以使分区更容易。目前，RESTRICT和CASCADE不起作用。 5.4 表插入数据#命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] 例如：往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99， 编号为3 的名为Wang 的成绩为96.5。 mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59); 注意：insert into每次只能向表中插入一条记录。 5.5 查询表中的数据#1)、查询所有行命令： select &lt;字段1，字段2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;例如：查看表 MyClass 中所有数据 mysql&gt; select * from MyClass; 2）、查询前几行数据例如：查看表 MyClass 中前2行数据mysql&gt; select * from MyClass order by id limit 0,2; select一般配合where使用，以查询更精确更复杂的数据。 5.6 删除表中数据#命令：delete from 表名 where 表达式 例如：删除表 MyClass中编号为1 的记录 mysql&gt; delete from MyClass where id=1; 下面是一个删除数据前后表的对比。 FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 下面以PHP代码为例删除 “Persons” 表中所有 LastName=’Griffin’ 的记录： 123456789&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;peter&quot;,&quot;abc123&quot;); if (!$con) &#123; die(&apos;Could not connect: &apos; . mysql_error()); &#125; mysql_select_db(&quot;my_db&quot;, $con); mysql_query(&quot;DELETE FROM Persons WHERE LastName=&apos;Griffin&apos;&quot;); mysql_close($con); ?&gt; 在这次删除之后，表是这样的： FirstName LastName Age Glenn Quagmire 33 5.7 修改表中数据#语法：update 表名 set 字段=新值,… where 条件 mysql&gt; update MyClass set name=’Mary’ where id=1; 例子1：单表的MySQL UPDATE语句： UPDATE [LOW_PRIORITY][IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] [ORDER BY …][LIMIT row_count] 例子2：多表的UPDATE语句：UPDATE [LOW_PRIORITY][IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] UPDATE语法可以用新值更新原有表行中的各列。SET子句指示要修改哪些列和要给予哪些值。WHERE子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。如果指定了ORDER BY子句，则按照被指定的顺序对行进行更新。LIMIT子句用于给定一个限值，限制可以被更新的行的数目。 5.8 增加字段#命令：alter table 表名 add字段 类型 其他;例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0 mysql&gt; alter table MyClass add passtest int(4) default ‘0’ 加索引 mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子： mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引 mysql&gt; alter table 表名 add primary key (字段名);例子： mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table 表名 add unique 索引名 (字段名);例子： mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引 mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name; 5.9 修改表名#命令：rename table 原表名 to 新表名; 例如：在表MyClass名字更改为YouClass mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 6、备份数据库#命令在DOS的[url=file://\\mysql\\bin]\\mysql\\bin[/url]目录下执行 1.导出整个数据库导出文件默认是存在mysql\\bin目录下​ mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名​ mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表​ mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名​ mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构​ mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql​ -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出​ mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa 7.1 一个建库和建表的实例1#drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘深圳’,​ year date); //建表结束 //以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令：​ mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 7.2 一个建库和建表的实例2#drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘’深圳’’,​ year date); //建表结束 //以下为插入字段insert into teacher values(‘’’’,’’glchengang’’,’’深圳一中’’,’’1976-10-10’’);insert into teacher values(‘’’’,’’jack’’,’’深圳一中’’,’’1975-12-23’’); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。","permalink":"http://www.hikoyan.design/2019/23/2-23/","photos":[]},{"tags":[{"name":"Hiko","slug":"Hiko","permalink":"http://www.hikoyan.design/tags/Hiko/"}],"title":"Hiko'Blog (^_-)","text":"Welcome ! 终于在情人节这天把所有的博客需要的配置啊、搞坏掉的自己的仓库和在返校前想边改代码shit山边吃掉的小零食都准备完毕了，✿✿ヽ(°▽°)ノ✿ 整理一下这几天的成果大概就是，学会了各种编辑器、mysql等等命令行中如何退出的方法，靠着东撞西撞瞎搞乱搞的摸鱼方式弄好了这个博客（完全没弄好）。总之 简单md一些可能以后也需要回过头来咀嚼的知♂识，顺便充实首页头版文章（看上去很丰富的样子），毕竟平时不怎么习惯网上分享什么心得什么感悟，要写的话就长篇大论还会陷入丧气的咸鱼状态就，不了不了。 首先是买的辣鸡腾讯的服务器，一开始装了centos，啊然后因为学习后续内容的时候要康教程啊，教程都是apt-get，虽然也有很多yum的……反正就是为了一致（放弃思考）就干脆从控制台那重装了系统。诶装LNMP的时候其实，虽然看到有一键脚本但是…（种种原因一切都手动配置了 大概花了两三天吧 25 X 3 hours)。手动配置的过程 其实很有意思，一开始接触vim的时候，诶第一次vim file 可能手抖打错文件名了，是个新文件，瞬间一脸懵也不知道怎么退出（虽然百度得到可是，我不知道要搜vim编辑器 我以为是突然什么东西…），还在insert的状态下打了：wq就很气了。 装php的时候，因为php更新了，但是2018年的教程仍然是php7.0，所以修改文件的时候经常找不到conf，然后一点点cd ..才发现 文件夹都 只有一个7.2 算了都是些沙雕操作。 mysql的一键安装似乎是没有给root加密码的，我记得我设过啊？反正直接重新创了一个blog用户 sudo进去给它加了权限，把时间花在这些上确实有点浪费，却也算是学到很多了。 接下来是1 修改PHP 登录注册的安全性问题还没好好做完呢，虽然hexo提供了插件，应该可以直接用多说之类的，一想到这好歹算是个必修能力，还是老老实实借了本书回来慢慢研究。2 页面美化 banner的图知道尺寸以后 打算去ai直接画一个自己的（弄完php还有时间的话） 虽然hexo的主页是↑←这样已经很不错的简约模板，出于学习的目的（而且也不是很明白ejs） 在留言板的页面中skip_layout了，嘛还有很多要做。 大年初十过得这么有意义真是よかった。","permalink":"http://www.hikoyan.design/2019/04/hello-world/","photos":[]}]}