{"meta":{"title":"Hiko's Blog","subtitle":"Things I Have.","description":"Hikoyan","author":"hiko","url":"https://hikohikoyan.gitee.io/hiko","root":"/"},"posts":[{"tags":[{"name":"计科","slug":"计科","permalink":"https://hikohikoyan.gitee.io/hiko/tags/计科/"},{"name":"JAVA","slug":"JAVA","permalink":"https://hikohikoyan.gitee.io/hiko/tags/JAVA/"}],"title":"JAVA EVERYDAY","text":"java是一个纯粹的面向对象的语言 .java文件执行前需要编译为字节码才能运行，和C C++不同的是java文化源代码编译后并不是可以直接在机器上执行的机器码，因此不同平台需要不同平台的编译器，而java则生成的是与平台无关的字节码，需要java虚拟机（JVM） eclipse:https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2019-12/R/eclipse-inst-win64.exe 命令行模式里：在cmd里 javac +*.java 编译 运行：java *(.class) main函数写法形如下↓ 123456public class App&#123; public static(类方法) void main(String args[]) &#123; &#125;&#125; simpleinput 12345678910import java.io.*;public class simpleinput&#123; public static void main(String args[]) throws IOException&#123; String s; BufferedReader ir; ir=new BufferdReader( new InputStreamReader(System.in)); s=ir.readline(); System.out.println(&quot;Input is:&quot;+s); &#125;&#125; 害就是个基础课（摸鱼了好久233333","permalink":"https://hikohikoyan.gitee.io/hiko/2020/13/post","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"https://hikohikoyan.gitee.io/hiko/tags/计科/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://hikohikoyan.gitee.io/hiko/tags/计算机网络/"}],"title":"计网笔记*N","text":"通信原理→网络 概念扩展→ 划重点：自主 独立自主性 资源 资源标识 传输协议 DT设备（自主设备） PSTM公用电话交换网络 中间件？集群？（同种 物理本地） 网格？（异构）中间件也是一种软件，MID WARE 集群就相当于是同构计算，设备基本相同时就互相连接起来，（刀片计算机) 古建筑未曾布线的建筑内的网络是无线网络，不是移动网络 互通就代表着协议 互操作就代表着理念相通","permalink":"https://hikohikoyan.gitee.io/hiko/2020/11/post","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"https://hikohikoyan.gitee.io/hiko/tags/计科/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hikohikoyan.gitee.io/hiko/tags/操作系统/"}],"title":"操作系统笔记*N","text":"就把这里当做复习营地了第一章 基础之基础图↑ 分层体系结构 其中下面三部分（硬件）属于计算机组成原理的内容 上层使用下层的服务，下层提供上层的服务接口，（通过服务接口调用），服务提供者和服务消费者。 操作系统是唯一的（唯一性），和硬件交互的唯一的软件（在现代操作系统中 为了安全性）就只有操作系统。其他所有软件都不能绕过操作系统。是唯一运行在核心太模式 内核的软件（kernel status) （老师念成了可乐四忒特四） 将复杂硬件调用接口简化、整合、抽象为一个更简单的调用方式（具体的系统抽象化 硬件软件化） 其他软件（包括系统软件 如编译器）则运行在用户太。 系统调用以区别于普通的过程调用 发展历史 组成原理简图（冯洛伊曼） CPU &amp;memory +I/O 设备 （外存属于I/0) 总线（Bus) PC指针 program counter 程序计数器，寻址单位是字节，最小单位是比特。Memory是唯一和CPU配合的，CPU不能直接到硬盘（I/O外围存储设备）拉取运行文件，需要先调入内存中。 用户视图（四层） BIOS（不使用操作系统的软件） 因此没有安装操作系统的计算机系统可以运行程序，有不使用操作系统的软件（嵌入式软件） GUI命令接口","permalink":"https://hikohikoyan.gitee.io/hiko/2020/09/post","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"https://hikohikoyan.gitee.io/hiko/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"https://hikohikoyan.gitee.io/hiko/tags/建模/"}],"title":"blender 学习（2）","text":"https://www.51sjsj.com/play.html?courseId=1617&amp;lessonId=23792 设计师之家的blender搬运视频教程 记一下自己每天的笔记，昨天尝试了基本操作，仍然有很多生硬的操作。看了视频以后发现，blender的选中物体（整个物体）时用的右键MRB，全选也不是ctrl+A而是A，这些操作的理由都非常清晰，不得不说开源的话建模发展不是一般的快，而且顺应程序和交互的逻辑。A的操作类似一个全选开关，如果按下A，所有的选中状态就从on/off切换了。 B是开启十字瞄准，按住左键MLB拖动就可以选中所有框选的物体（基本和其他软件一致），按住中键MMB拖动–减选，而右键此时的操作则是取消（事实上任何时候取消一个工具的操作都可以按MRB） C是开启笔刷刷选（其他软件可能是画圆），滚轴可以缩放笔刷的半径， G对应（grab抓取）移动，这也是Move并不是M的原因，移动本来是要根据三轴移动的，不过自由摆放就更像抓取？2333 按下G以后边线会变成高亮的白色（不是橙色） R对应rotate旋转，（按两下R是自由旋转）S对应scale，加alt还原到初始的变换。 MLB确认 MRB取消不过这些变换操作基本，上是根据视平面的（当前的平面方向），结合 X Y Z变化视平面就可以更自由地变换了 shift+a是个快捷菜单 可以添加物体，之前说的3d游标就作为物体的出生点 按下T就可以看见create分栏，选择更多物体 H（hide)隐藏模型，alt+H还原（所有隐藏物体），如果想特定显示某个隐藏了的物体就到菜单的层次里点那个眼睛（类似ps的图层操作吧）alt+H有时也只显示当前图层的物体 M move layer+数字键（不能是数字键盘） 把物体移到第n个图层这个操作有点麻烦（文字写出来的话） tab进入编辑模式。Nurbs模型和 UV模型，一个是表面网格一个是网格模型（常规的多边形网格模型 如果光滑着色的话两个看起来非常像），而Nurbs是由数学等式和方程生成的，操作比较有限，但十分光滑。 UV+渲染输出嘛在掌握基础操作以后制作UV就容易多了，2.8+版本里的uv editor 和texture界面都比较清楚，按U（按住是智能UV展开）可以展开UV并在editor里制作UV分布图。注意的是如果直接按A会选中所有的面，一次性展开的话如果你的模型各个方向上的面选起来比较麻烦的话，所有UV都叠在一起你会很难去到PS里绘制，所以建议手动选面（不依靠插件什么的话）然后分好组按U展开（比如我要做的是柱体的话 可能会是按视图展开，也可以柱体展开）。 展开完成后A全选UV布局 选择那个小菜单栏里的“UV”，可以并排减少冗余（如果你的UV都很大 亲这边建议手动缩放）） 导出到PS就可以开始绘制啦，绘制完后再UV那导入图像 切到texture新建一个材质并在颜色后面那个小点上选择（对那个点是可以展开菜单的，哇就是因为这个我还特地去翻手册 总感觉没有一点提示 UI做的一般般（swtcl）可以选择你刚刚导入的图像纹理，然后选择预览渲染效果，贴图就贴上了。 调好灯光什么的 包括节点（其实创建的时候 选择使用节点就会在shading那里有了 同步可以编辑的） 选择渲染导出（渲染图像 查看渲染结果英文对应 recent result 所以如果发现图像没变不用焦急哈） 相机大小可以直接在右侧编辑器里改数值 建议不要动侧边 小字工具的x y比例 那个会压扁图像的。 今日成果 12v北浮电池一个~","permalink":"https://hikohikoyan.gitee.io/hiko/2020/06/post","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"https://hikohikoyan.gitee.io/hiko/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"https://hikohikoyan.gitee.io/hiko/tags/建模/"}],"title":"blender学习之路","text":"从如何编辑开始 其实掌握一门建模软件并不是难事，都是对一个应用的熟悉到熟练的过程吧（虽然我可能没资格说这话） blender的三种编辑模式比较不一样（有可能是因为我建模入门是从最简单的SU开始的，对这个有些膈应） https://docs.blender.org/manual/zh-hans/2.80/modeling/meshes/structure.html blender的中文手册 感谢翻译~ 三个(三角面)，四个(四边面)或更多(n边面)顶点之间的区域定义为面，每侧都有一条边，通常缩写为 tris，quads ＆ n-gons。 三角形总是平坦的，因此易于计算。另一方面，四边形 “利于形变”，因此常用于动画和细分建模。 网格是3D场景中使用的常见物体类型。Blender配有一些 “基本” 网格形状，用户可以之为起点开始建模。编辑模式下，可以在3D游标位置添加基本体。 这个3D游标一开始使用起来真的很苦恼，尤其是Move的快捷键是G ，我实在不明白为什么是G 而且考虑到快捷键M应该有对应的了（有些教程也不改快捷键）所以就也没有去自定义。 重要的是blender建模有三种模式，热键分别对应1,2,3（shift多选 ctrl缩减或扩展选择),这个和其他的类似但是实际操作起来有点累（swtcl) 顶点模式下顶点会被显示为点。选中的顶点显示为橙色，未选中的顶点显示为黑色，当前活动的顶点或最后选择的顶点显示为白色。 边模式下顶点不显示。 不同的是，选中的边显示为橙色，未选中的边显示为黑色，当前活动的边或最后选择的边显示为白色。 面模式 面将伴随着一个用于对面进行选择的选择点在其中央进行显示。 选中的面及其选择点显示为橙色，未选中的面显示为黑色，当前激活的面或最后选择的面呈现白色高亮状态。 对我来说面模式是最接近SU操作的一个了 所以我经常在边模式和面模式中反复切换（ 按下dele键的时候可以选择删除的内容（还有其他操作） 刷选前在右侧属性设置好刷子的半径 配合shift ctrl就可以快速选面了 加/减选 扩展选区 Ctrl-数字键盘+ 扩展到当前选择模式下与选中区域相连的区域。 缩减选区 Ctrl-数字键盘- 从当前选择模式下选中区域相连的部分缩减选择。 下一活动元素 Shift-Ctrl-数字键盘+ 该功能利用了选择历史来基于环绕拓扑对下一个顶点、边、面进行选择。 上一活动元素 Shift-Ctrl-数字键盘- 选择前一活动元素并取消对最后选择元素的选择状态。","permalink":"https://hikohikoyan.gitee.io/hiko/2020/05/post","photos":[]},{"tags":[{"name":"MySql","slug":"MySql","permalink":"https://hikohikoyan.gitee.io/hiko/tags/MySql/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hikohikoyan.gitee.io/hiko/tags/Ubuntu/"},{"name":"Git","slug":"Git","permalink":"https://hikohikoyan.gitee.io/hiko/tags/Git/"}],"title":"这就是个笔记汇总啦","text":"临近开学（任务检查）之际 ，又努力学习了一波。 Ubuntu指令 LIst 常用指令123456789101112131415161718192021222324&gt;pwd 当前工作目录 pwd&gt; ls 当前目录内容(list) ls&gt; mkdir 创建目录(makedir) mkdir books&gt; cd 进入目录 cd books&gt; touch 生成空文件 touch book.txt&gt; echo 带内容的文件 echo &quot;内容&quot; &gt; book.txt&gt; cp 拷贝文件（copy） cp book.txt book.txt.bak&gt; rm 删除文件（remove） rm -r（删除所有文件）/-f（强制删除） book.txt&gt; rm -rf +foldername 删除文件夹 &gt; rmdir 删除空目录 rmdir 空目录&gt; mv 移动文件（move） mv 原文件 目标位置&gt; mv 重命名 mv a.txt b.txt&gt; find 查找文件 find [指定目录] -name 文件名&gt; grep 查找指定文件里的内容 grep &quot;是否有包含内容&quot; book.txt&gt; wc 统计文本的行数字符数 wc book.txt&gt; tree 树状目录 tree&gt; ln 建立软链接（link） ln -s 目标目录 链接目录（快捷方式）&gt; cat 查看文件内容 cat book.txt&gt; more 分页显示文件内容&gt; less 分页显示文件内容&gt; head 显示文本开头内容&gt; tail 显示文件内容结尾内容&gt; vim编辑器： ：wq保存并退出 ：q直接退出 ：/搜索+要搜寻的字符串 （按n 下一个匹配的字符&gt; -s 是代号（symbolic）的意思 ln命令会保持每一处链接文件的同步性——不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接和硬链接两种，软链接就是ln –s 它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。 将档案 yy 产生一个 symbolic link : zz ln -s yy zz 文件夹建立软链接（用绝对地址） ln -s 源地址 目的地 常用 Git 命令1.新建代码库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.配置 12345678910&gt; # 显示当前的Git配置&gt; $ git config --list&gt; &gt; # 编辑Git配置文件&gt; $ git config -e [--global]&gt; &gt; # 设置提交代码时的用户信息&gt; $ git config [--global] user.name \"[name]\"&gt; $ git config [--global] user.email \"[email address]\"&gt; 3.增删改 123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 4.分支 123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 5.标签tag 1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 6.变化历史查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git fetch origin git reset –hard MYSQL 创建数据库注意：创建数据库之前要先连接Mysql服务器 命令：create database &lt;数据库名&gt; 例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb; 例2：创建数据库并分配用户 ①CREATE DATABASE 数据库名; ②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’; ③SET PASSWORD FOR ‘数据库名‘@’localhost’ = OLD_PASSWORD(‘密码’); 依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。 4.2 显示数据库命令：show databases （注意：最后有个s）mysql&gt; show databases; 注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明： 1、修改MYSQL的配置文件：my.ini里面修改default-character-set=gbk2、代码运行时修改： ①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk ②PHP代码：header(“Content-Type:text/html;charset=gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL mysql, char csname)；该函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。 4.3 删除数据库命令：drop database &lt;数据库名&gt;例如：删除名为 xhkdb的数据库mysql&gt; drop database xhkdb; 例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist​ //发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec) 4.4 连接数据库命令： use &lt;数据库名&gt; 例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb;屏幕提示：Database changed use 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor​ -&gt; WHERE author.editor_id = db2.editor.editor_id; USE语句被设立出来，用于与Sybase相兼容。 有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。 4.5 当前选择的数据库命令：mysql&gt; select database(); MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？ 1.显示MYSQL的版本mysql&gt; select version();+———————–+| version() |+———————–+| 6.0.4-alpha-community |+———————–+1 row in set (0.02 sec) 显示当前时间mysql&gt; select now();+———————+| now() |+———————+| 2009-09-15 22:35:32 |+———————+1 row in set (0.04 sec) 显示年月日SELECT DAYOFMONTH(CURRENT_DATE);+————————–+| DAYOFMONTH(CURRENT_DATE) |+————————–+| 15 |+————————–+1 row in set (0.01 sec) SELECT MONTH(CURRENT_DATE);+———————+| MONTH(CURRENT_DATE) |+———————+| 9 |+———————+1 row in set (0.00 sec) SELECT YEAR(CURRENT_DATE);+——————–+| YEAR(CURRENT_DATE) |+——————–+| 2009 |+——————–+1 row in set (0.00 sec) 显示字符串mysql&gt; SELECT “welecome to my blog!”;+———————-+| welecome to my blog! |+———————-+| welecome to my blog! |+———————-+1 row in set (0.00 sec) 当计算器用select ((4 4) / 10 ) + 25;+———————-+| ((4 4) / 10 ) + 25 |+———————-+| 26.60 |+———————-+1 row in set (0.00 sec) 串接字符串select CONCAT(f_name, “ “, l_name)AS Namefrom employee_datawhere title = ‘Marketing Executive’;+—————+| Name |+—————+| Monica Sehgal || Hal Simlai || Joseph Irvine |+—————+3 rows in set (0.00 sec)注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列’CONCAT(f_name, “ “, l_name)’起了个假名。 5.1 创建数据表命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 例如，建立一个名为MyClass的表， 字段名 数字类型 数据宽度 是否为空 是否主键 自动增加 默认值 id int 4 否 primary key auto_increment name char 20 否 sex int 4 否 0 degree double 16 是 mysql&gt; create table MyClass( > id int(4) not null primary key auto_increment , > name char(20) not null, > sex int(4) not null default ‘0’, > degree double(16,2)); 5.3 删除数据表命令：drop table &lt;表名&gt; 例如：删除表名为 MyClass 的表 mysql&gt; drop table MyClass; DROP TABLE用于取消一个或多个表。您必须有每个表的DROP权限。所有的表数据和表定义会被取消，所以使用本语句要小心！ 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 RESTRICT和CASCADE可以使分区更容易。目前，RESTRICT和CASCADE不起作用。 5.4 表插入数据命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] 例如：往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99， 编号为3 的名为Wang 的成绩为96.5。 mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59); 注意：insert into每次只能向表中插入一条记录。 5.5 查询表中的数据1)、查询所有行命令： select &lt;字段1，字段2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;例如：查看表 MyClass 中所有数据 mysql&gt; select * from MyClass; 2）、查询前几行数据例如：查看表 MyClass 中前2行数据mysql&gt; select * from MyClass order by id limit 0,2; select一般配合where使用，以查询更精确更复杂的数据。 5.6 删除表中数据命令：delete from 表名 where 表达式 例如：删除表 MyClass中编号为1 的记录 mysql&gt; delete from MyClass where id=1; 下面是一个删除数据前后表的对比。 FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 下面以PHP代码为例删除 “Persons” 表中所有 LastName=’Griffin’ 的记录： 123456789&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;peter&quot;,&quot;abc123&quot;); if (!$con) &#123; die(&apos;Could not connect: &apos; . mysql_error()); &#125; mysql_select_db(&quot;my_db&quot;, $con); mysql_query(&quot;DELETE FROM Persons WHERE LastName=&apos;Griffin&apos;&quot;); mysql_close($con); ?&gt; 在这次删除之后，表是这样的： FirstName LastName Age Glenn Quagmire 33 5.7 修改表中数据语法：update 表名 set 字段=新值,… where 条件 mysql&gt; update MyClass set name=’Mary’ where id=1; 例子1：单表的MySQL UPDATE语句： UPDATE [LOW_PRIORITY][IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] [ORDER BY …][LIMIT row_count] 例子2：多表的UPDATE语句：UPDATE [LOW_PRIORITY][IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] UPDATE语法可以用新值更新原有表行中的各列。SET子句指示要修改哪些列和要给予哪些值。WHERE子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。如果指定了ORDER BY子句，则按照被指定的顺序对行进行更新。LIMIT子句用于给定一个限值，限制可以被更新的行的数目。 5.8 增加字段命令：alter table 表名 add字段 类型 其他;例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0 mysql&gt; alter table MyClass add passtest int(4) default ‘0’ 加索引 mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子： mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引 mysql&gt; alter table 表名 add primary key (字段名);例子： mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table 表名 add unique 索引名 (字段名);例子： mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引 mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name; 5.9 修改表名命令：rename table 原表名 to 新表名; 例如：在表MyClass名字更改为YouClass mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 6、备份数据库命令在DOS的[url=file://\\mysql\\bin]\\mysql\\bin[/url]目录下执行 1.导出整个数据库导出文件默认是存在mysql\\bin目录下​ mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名​ mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表​ mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名​ mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构​ mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql​ -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出​ mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa 7.1 一个建库和建表的实例1drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘深圳’,​ year date); //建表结束 //以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令：​ mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 7.2 一个建库和建表的实例2drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘’深圳’’,​ year date); //建表结束 //以下为插入字段insert into teacher values(‘’’’,’’glchengang’’,’’深圳一中’’,’’1976-10-10’’);insert into teacher values(‘’’’,’’jack’’,’’深圳一中’’,’’1975-12-23’’); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。","permalink":"https://hikohikoyan.gitee.io/hiko/2019/23/2-23","photos":[]},{"tags":[{"name":"Hiko","slug":"Hiko","permalink":"https://hikohikoyan.gitee.io/hiko/tags/Hiko/"}],"title":"Hiko'Blog (^_-)","text":"Welcome ! 终于在情人节这天把所有的博客需要的配置啊、搞坏掉的自己的仓库和在返校前想边改代码shit山边吃掉的小零食都准备完毕了，✿✿ヽ(°▽°)ノ✿ 整理一下这几天的成果大概就是，学会了各种编辑器、mysql等等命令行中如何退出的方法，靠着东撞西撞瞎搞乱搞的摸鱼方式弄好了这个博客（完全没弄好）。总之 简单md一些可能以后也需要回过头来咀嚼的知♂识，顺便充实首页头版文章（看上去很丰富的样子），毕竟平时不怎么习惯网上分享什么心得什么感悟，要写的话就长篇大论还会陷入丧气的咸鱼状态就，不了不了。 首先是买的辣鸡腾讯的服务器，一开始装了centos，啊然后因为学习后续内容的时候要康教程啊，教程都是apt-get，虽然也有很多yum的……反正就是为了一致（放弃思考）就干脆从控制台那重装了系统。诶装LNMP的时候其实，虽然看到有一键脚本但是…（种种原因一切都手动配置了 大概花了两三天吧 25 X 3 hours)。手动配置的过程 其实很有意思，一开始接触vim的时候，诶第一次vim file 可能手抖打错文件名了，是个新文件，瞬间一脸懵也不知道怎么退出（虽然百度得到可是，我不知道要搜vim编辑器 我以为是突然什么东西…），还在insert的状态下打了：wq就很气了。 装php的时候，因为php更新了，但是2018年的教程仍然是php7.0，所以修改文件的时候经常找不到conf，然后一点点cd ..才发现 文件夹都 只有一个7.2 算了都是些沙雕操作。 mysql的一键安装似乎是没有给root加密码的，我记得我设过啊？反正直接重新创了一个blog用户 sudo进去给它加了权限，把时间花在这些上确实有点浪费，却也算是学到很多了。 接下来是1 修改PHP 登录注册的安全性问题还没好好做完呢，虽然hexo提供了插件，应该可以直接用多说之类的，一想到这好歹算是个必修能力，还是老老实实借了本书回来慢慢研究。2 页面美化 banner的图知道尺寸以后 打算去ai直接画一个自己的（弄完php还有时间的话） 虽然hexo的主页是↑←这样已经很不错的简约模板，出于学习的目的（而且也不是很明白ejs） 在留言板的页面中skip_layout了，嘛还有很多要做。 大年初十过得这么有意义真是よかった。","permalink":"https://hikohikoyan.gitee.io/hiko/2019/04/hello-world","photos":[]}]}