{"meta":{"title":"Hiko's Blog","subtitle":"Things I Have.","description":"Hikoyan","author":"hiko","url":"http://www.hikoyan.design","root":"/"},"posts":[{"tags":[],"title":"HEXO问题一大堆","text":"1 部署后点击阅读下载post的问题 2 typora+picgo failed to fetch 1 部署后点击阅读下载post的问题#问题描述： hexog没问题 hexo d没问题 问题就在网页部署之后可以正常看/archives /tags /categries 但是！不能看各个文章（如果可以 请检查是否是缓存！） 点击文章阅读链接后，发现实际进入链接和正常的（文章永久链接）不一致，是“https://……/post”，在chrome里可能是因为自动识别为源文件链接（hexo s本地预览时），于是给我下载了一堆“post”文件，对没有后缀的那种。 部署后再点击居然就变成了↓ 我觉得应该是yml里root没写对的问题，也可能是之前prettyurl时设置了隐藏后缀.html，网上搜了很久似乎没看到类似问题 检查了配置后康到url后有仓库名 gitee.io/foo 然后root我写的是/这样子会出错，但是我gitee仓库确实有foo的仓库名（导入的github仓嘛），删掉仓库名后恢复正常了，但并没有明白原因2333（反正一定是路由的问题 hexo deploy的部署路由设置有问题（但我明明都设对的？） 2 typora+picgo failed to fetch#这个遇到了发现原先picgo监听的端口被别的占用了于是改了picgo的server，结果typora默认是36677端口，没找到对应配置文件修改，害所以我就把原来占的端口腾出来给picgo了，如果图床设置没问题还报错（包括picgo的js报错，就要考虑是不是两个软件本身配置的问题了）","permalink":"http://www.hikoyan.design/2020/13/question/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"JAVA","slug":"JAVA","permalink":"http://www.hikoyan.design/tags/JAVA/"}],"title":"JAVAEVERYDAY","text":"java是一个纯粹的面向对象的语言 .java文件执行前需要编译为字节码才能运行，和C C++不同的是java文化源代码编译后并不是可以直接在机器上执行的机器码，因此不同平台需要不同平台的编译器，而java则生成的是与平台无关的字节码，需要java虚拟机（JVM） eclipse:https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2019-12/R/eclipse-inst-win64.exe 命令行模式里：在cmd里 javac +*.java 编译 运行：java *(.class) main函数写法形如下↓ 123456public class App&#123; public static(类方法) void main(String args[]) &#123; &#125;&#125; simpleinput 12345678910import java.io.*;public class simpleinput&#123; public static void main(String args[]) throws IOException&#123; String s; BufferedReader ir; ir=new BufferdReader( new InputStreamReader(System.in)); s=ir.readline(); System.out.println(&quot;Input is:&quot;+s); &#125;&#125; 基本类型所指向的内存空间就是他的值， 因此这里y是1 而引用类型，x所指向的是自己的地址（x[]={1,2,3},x=location(eg.010110)),y=x,则y获取的是所指向地址","permalink":"http://www.hikoyan.design/2020/13/post/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.hikoyan.design/tags/计算机网络/"}],"title":"计网笔记*N","text":"[TOC] 计算机网络 中间件 同轴电缆 TPC双绞线 UTP 屏蔽双绞线STP 网屏式双绞线 光纤 选择传输介质 复用技术 频分多路复用FDM 正交FDM (OFDM) 波分多路复用WDM 时分多路复用技术TDM 统计时分多路复用技术STDM 码分多路复用CDMA 计算机网络# 通信原理→网络 概念扩展→ 划重点：自主 独立自主性 资源 资源标识 传输协议 DT设备（自主设备） PSTM公用电话交换网络 中间件#集群|（同种 物理本地） 网格|（异构） 中间件也是一种软件，MID WARE 集群就相当于是同构计算，设备基本相同时就互相连接起来，（刀片计算机) 古建筑未曾布线的建筑内的网络是无线网络，不是移动网络 互通就代表着协议 互操作就代表着理念相通 同轴电缆# TPC双绞线# 双绞线分为非屏蔽和屏蔽 UTP#unshielded twisted pair 水平电缆 用户桌面使用 受绞距影响大 屏蔽双绞线STP#（横切图） 优点就是抗EMI/RFI 干扰 缺点 成本高 安装不易（体积大 双层防护屏蔽 网屏式双绞线#只有一层屏蔽和保护 仍具有抗干扰能力 光纤#作为干线使用 充当垂直电缆 带宽高 距离远 传输快重量轻 无电磁干扰和射频干扰 防窃听 但价格高昂 光纤连接器（光损失10%——20% 机械拼接 特殊的套管夹紧 （光损失10%） 熔合（光纤熔接机）若没有气泡和凹凸 几乎没有任何光损失 单模：8.3/125μm 8.3指的是内径 125指外径（均为直径） 多模 62.5/125μm 选择传输介质# 引导性（有线） 非引导性（无线 ） 复用技术#用在干线上的技术，干线起点如何共用，干线终点如何分离的问题 频分多路复用FDM#在干线起点，信道的频谱被分成若干段（子带），每个用户占据一段来传输自己的信号 正交FDM (OFDM)# 同样的干线可以承载更多的用户，传输效率得到了极大的提升，被广泛使用与802.11 有线电视网络 波分多路复用WDM# 时分多路复用技术TDM# 广泛用于蜂窝网络 统计时分多路复用技术STDM#只在告诉远程通信中使用 不适于用户平均使用信道中 码分多路复用CDMA#允许基站利用整个频段，且无时间限制 每个比特被分为64个或128个 以下哪个不属于PSTN的主要构成？ A.本地回路 B.干线 C.交换局 D.端局 参考答案：D 解析：PSTN三部分分别为：本地回路、干线、交换局","permalink":"http://www.hikoyan.design/2020/11/post/","photos":[]},{"tags":[{"name":"计科","slug":"计科","permalink":"http://www.hikoyan.design/tags/计科/"},{"name":"操作系统","slug":"操作系统","permalink":"http://www.hikoyan.design/tags/操作系统/"}],"title":"操作系统笔记*N","text":"就把这里当做复习营地了 [TOC] 第一章 发展历史 总线（Bus) 用户视图（四层） 操作系统的类型 处理器 中断 第一章习题 第二章 第一章# 基础之基础图↑ 分层体系结构 其中下面三部分（硬件）属于计算机组成原理的内容 上层使用下层的服务，下层提供上层的服务接口，（通过服务接口调用），服务提供者和服务消费者。 操作系统是唯一的（唯一性），和硬件交互的唯一的软件（在现代操作系统中 为了安全性）就只有操作系统。其他所有软件都不能绕过操作系统。是唯一运行在核心太模式 内核的软件（kernel status) （老师念成了可乐四忒特四） 将复杂硬件调用接口简化、整合、抽象为一个更简单的调用方式（具体的系统抽象化 硬件软件化） 其他软件（包括系统软件 如编译器）则运行在用户太。 系统调用以区别于普通的过程调用 发展历史# 组成原理简图（冯洛伊曼） CPU &amp;memory +I/O 设备 （外存属于I/0) 总线（Bus)# PC指针 program counter 程序计数器，寻址单位是字节，最小单位是比特。Memory是唯一和CPU配合的，CPU不能直接到硬盘（I/O外围存储设备）拉取运行文件，需要先调入内存中。 用户视图（四层）# BIOS（不使用操作系统的软件） 因此没有安装操作系统的计算机系统可以运行程序，有不使用操作系统的软件（嵌入式软件） GUI命令接口 操作系统的类型# 处理器# 中断#中断调用interuput call 重点 过程调用 系统调用system call（internal 中断向量 中断历程 中断嵌套 程序中断是最低等级的 最高等级的 中等的 高的 程序状态字(PSW)是用来控制指令执行顺序并且保留和指示与程序有关的系统状态。一般包括三部分内容：程序基本状态(指令地址、条件码、管目态位等)；中断码；中断屏蔽位，所以选择B、C、D。每个程序都有一个程序状态字，但整个系统设置一个程序状态字寄存器，存放当前正在运行程序的程序状态字。 计算机系统都有自己的指令系统，在多道程序设计系统中，指令系统分为特权指令与非特权指令。特权指令仅能由操作系统使用，如设置时钟、清内存等为特权指令；其他指令为非特权指令，用户只能使用非特权指令。若中央处理机处于目态，仅可以执行非特权指令，在备选答案中，读系统时钟、读用户内存自身数据都属于非特权指令，它们的执行不会构成对系统的破坏，而清除整个内存，则可能造成对系统的破坏，所以在目态下不能执行，只能在管态下执行。 用户与操作系统的接口有：1、程序一级的系统调用；2、命令解释和键盘命令；3、联机或交互式用户的接口；4、脱机或批处理用户的接口E用户内部和外部命令。 微内核↑ 哑终端（早期 任何一个终端要靠主机回显 没有处理能力 只有键盘↑ 伪终端 ←为保证可兼容性 将有处理能力的终端适配哑终端 虚拟终端（图形终端）→有GUI界面 通过软件来模拟终端（没有实 际终端 远程终端 telnet SSH 第一章习题#1.操作系统的两大主要作用是什么 一是作为扩展机器为用户与底层硬件交互提供可扩展的抽象，二是作为资源管理者，为应用程序提供基本的资源集的清晰抽象 （另一种说法：操作系统给用户提供了一个可扩展的机器。个人理解是通过对底层的抽象，对外提供各种接口支持扩展） 2.管理各种软硬件资源 2.分时系统和多道程序系统的区别是什么 在分时系统中，多个用户可以使用他们自己的终端同时访问和执行计算系统上的计算。 多道程序设计系统允许用户同时运行多个程序。 所有分时系统都是多道程序设计系统，但并非所有多道程序设计系统都是分时系统，因为多道程序设计系统可以在只有一个用户的PC上运行。 10.内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同的模式有什么帮助。 大多数现代CPU提供两种执行模式：内核态和用户态。管态下可以执行其指令集中的每条指令，并使用硬件的各种功能。 但是用户态只能执行部分指令，执行时仅使用部分功能。 拥有两种模式允许设计人员以用户态运行用户程序，从而拒绝他们访问关键指令。 12、下面ACD条指令只能在内核态使用？ a 禁止所有的中断 b 读日期-时间时钟 c 设置日期-时间时钟 d 改变存储器映像 13、考虑一个有两个CPU的系统，且每一个CPU有两个线程（超线程）。假设有三个程序P0、P1、P2，分别以运行时间5ms, 10ms,20ms开始，运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻赛，并且一旦设定就不改变CPU。 答： 完成这些程序的执行可能需要20,25或30毫秒，具体取决于操作系统如何安排它们。 如果P0和P1在同一个CPU上进行调度，而P2在另一个CPU上进行调度，则需要20毫秒。 如果P0和P2安排在同一个CPU上并且P1安排在另一个CPU上，则需要25毫秒。 如果P1和P2安排在同一个CPU上并且P0安排在另一个CPU上，则需要30毫秒。 如果所有三个都在同一个CPU上，则需要35毫秒。 14、一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns, 这台机器每秒可执行多少条指令？ 答：每一纳秒的指令都从管道中出现。 这意味着机器每秒执行10亿条指令。 根本没关系管道有多少个阶段。 每级1 nsec的10级流水线每秒也会执行10亿条指令。 重要的是完成的指令弹出管道末端的频率。 15.假设一个计算机系统有高速缓存、内存以及磁盘，操作系统用呼你内存。读取缓存中的一个词需要1ns, 内存需要10ns, 磁盘需要10ms。如果缓存命中率是95%， 内存的是99%（缓存失效时），读取一个词的平均时间是多少？ 答：平均访问时间=0.95×1 nsec（词在缓存中） 0.05×0.99×10 nsec（词在RAM中，但不在缓存中） 0.05×0.01×10,000,000 nsec（仅限磁盘上的词）= 5001.445纳秒=5.001445μsec 16.在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？ 答：也许。如果调用者取回控制，并且在最终发生写操作时立即重写数据，将会写入错误的数据。然而，如果驱动程序在返回之前首先复制将数据复制到一个专用的缓冲器，那么调用者可以立即继续执行。另一个可能性是允许调用者继续，并且在缓冲器可以再用时给它一个信号，但是这需要很髙的技巧，而且容易出错。 17.什么是陷阱指令？在操作系统中他的用途。 陷阱指令将一个处理器的执行模式从用户模式切换到内核模式。该指令允许用户程序调用操作系统内核中的函数。 18.分时系统中为什么需要进程表？在只有一个进程存在的计算机中，需要进程表吗、 进程表是为了存储当前被挂起、甚或是被延迟和阻塞的进程状态。在单一进程的系统中是不需要，因为单一进程从不挂起。 23.有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用： lseek(fd, 3, SEEK_SET); read(fd, &amp;buffer, 4); 其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？ 答：1, 5, 9, 2 24.假设一个10MB的文件在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？ 假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是100MB/s。 答：找到文件需要的时间=1 50 ms (移动到50轨道号的时间) + 5 ms (旋转到文件开始部分存储在的扇区的时间) + 10/100 1000 ms (读取10MB的时间) = 155 ms 25.块特殊文件和字符特殊文件的基本差别是什么？ 答：块特殊文件包含被编号的块，每一块都可以独立地读取或者写入。而且可以定位于任何块，并且开始读出或写入。这些对于字符特殊文件是不可能的。 26.在图1-7的例子中库调用称为read，而系统调用自身称为read，这两者都有相问的名字是正常的吗？ 如果不是，哪一个更重要？ 系统调用实际上并没有名称，除了在文件中这样描述之外。当库例程read陷入内核时，它将系统调用号码放入寄存器或者堆栈中。该号码通常用于一张表的索引。这里确实没有使用任何名称。而另一方面，库例程的名称是十分重要的，因为它将用于程序中。 27、现代操作系统将进程的地址空间从机器物理内存中分离出来，列举这种设计的两个好处。 这允许可执行程序在不同的运行中 加载到机器内存的不同部分。 此外，它还使程序大小可以超过机器内存的大小（虚拟内存）。 28、对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？ 答：就程序逻辑而言，库例程调用哪个系统调用是没有关系的。但是，如果需要考虑性能问题，无需系统调用就可以完成的任务将使程序运行更快。所有的系统调用都会导致用户环境和内核环境的切换开销。更进一步，在多用户系统中，在系统调用完成之前，操作系统可能调度到其他的进程，这将使得调用过程的处理更加迟缓。 29、图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API，对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？ 答：某些 UNIX调用没有相应的Win32 API: Link: Win32程序不能给文件另外一个名称，或者使某个文件出现在多个目录中。同时，试图创建链接可以便于测试，并且在文件上加锁。 Mount和umount: Wmdows程序不能创建关于标准的路径的假定命名，因为具有多个磁盘驱动器的系统上路径名，其驱动器部分是不同的。 Chmod: Windows程序员不得不假定所有的用户都能访问每个文件。 Kill: Windows程序员不能kill行为失常的程序。 30、可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个髙度可移植的操作系统时你设计的高级的两层是什么样的。 答：每一个系统体系结构都有它自己可以执行的一套指令。因此，奔腾不能执行SPARC程序或者SPARC无法执行奔腾程序。另外，不同的架构使用不同的总线架构（如VME总线，ISA，PCI，MCA，SBU，…）以及CPU的字长（通常是32或64位）。由于硬件上的这些差异，建立一个完全可移植的操作系统是不可行的。一个高度可移植的操作系统将包括两个高级层——一个机器相关层和一个机器独立层。机器相关层屏蔽硬件的细节，必须为每一个架构单独实现，该层提供了一个统一的接口。机器独立层只需要实现一次。为了实现高度可移植，机器相关层应尽可能小 31、请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。 答：策略和机制的分离，使操作系统的设计人员在内核中实现了少量的基本原语。这些原语被简化，因为它们不依赖于任何特定的策略。然后，它们在用户级别可以被用来实现更复杂的机制和策略。 第二章#","permalink":"http://www.hikoyan.design/2020/09/post/","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"http://www.hikoyan.design/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"http://www.hikoyan.design/tags/建模/"}],"title":"blender 学习（2）","text":"https://www.51sjsj.com/play.html?courseId=1617&amp;lessonId=23792 设计师之家的blender搬运视频教程 记一下自己每天的笔记，昨天尝试了基本操作，仍然有很多生硬的操作。#看了视频以后发现，blender的选中物体（整个物体）时用的右键MRB，全选也不是ctrl+A而是A，这些操作的理由都非常清晰，不得不说开源的话建模发展不是一般的快，而且顺应程序和交互的逻辑。A的操作类似一个全选开关，如果按下A，所有的选中状态就从on/off切换了。 B是开启十字瞄准，按住左键MLB拖动就可以选中所有框选的物体（基本和其他软件一致），按住中键MMB拖动–减选，而右键此时的操作则是取消（事实上任何时候取消一个工具的操作都可以按MRB） C是开启笔刷刷选（其他软件可能是画圆），滚轴可以缩放笔刷的半径， G对应（grab抓取）移动，这也是Move并不是M的原因，移动本来是要根据三轴移动的，不过自由摆放就更像抓取？2333 按下G以后边线会变成高亮的白色（不是橙色） R对应rotate旋转，（按两下R是自由旋转）S对应scale，加alt还原到初始的变换。 MLB确认 MRB取消不过这些变换操作基本，上是根据视平面的（当前的平面方向），结合 X Y Z变化视平面就可以更自由地变换了 shift+a是个快捷菜单 可以添加物体，之前说的3d游标就作为物体的出生点 按下T就可以看见create分栏，选择更多物体 H（hide)隐藏模型，alt+H还原（所有隐藏物体），如果想特定显示某个隐藏了的物体就到菜单的层次里点那个眼睛（类似ps的图层操作吧）alt+H有时也只显示当前图层的物体 M move layer+数字键（不能是数字键盘） 把物体移到第n个图层这个操作有点麻烦（文字写出来的话） tab进入编辑模式。Nurbs模型和 UV模型，一个是表面网格一个是网格模型（常规的多边形网格模型 如果光滑着色的话两个看起来非常像），而Nurbs是由数学等式和方程生成的，操作比较有限，但十分光滑。 UV+渲染输出#嘛在掌握基础操作以后制作UV就容易多了，2.8+版本里的uv editor 和texture界面都比较清楚，按U（按住是智能UV展开）可以展开UV并在editor里制作UV分布图。注意的是如果直接按A会选中所有的面，一次性展开的话如果你的模型各个方向上的面选起来比较麻烦的话，所有UV都叠在一起你会很难去到PS里绘制，所以建议手动选面（不依靠插件什么的话）然后分好组按U展开（比如我要做的是柱体的话 可能会是按视图展开，也可以柱体展开）。 展开完成后A全选UV布局 选择那个小菜单栏里的“UV”，可以并排减少冗余（如果你的UV都很大 亲这边建议手动缩放）） 导出到PS就可以开始绘制啦，绘制完后再UV那导入图像 切到texture新建一个材质并在颜色后面那个小点上选择（对那个点是可以展开菜单的，哇就是因为这个我还特地去翻手册 总感觉没有一点提示 UI做的一般般（swtcl）可以选择你刚刚导入的图像纹理，然后选择预览渲染效果，贴图就贴上了。 调好灯光什么的 包括节点（其实创建的时候 选择使用节点就会在shading那里有了 同步可以编辑的） 选择渲染导出（渲染图像 查看渲染结果英文对应 recent result 所以如果发现图像没变不用焦急哈） 相机大小可以直接在右侧编辑器里改数值 建议不要动侧边 小字工具的x y比例 那个会压扁图像的。 今日成果 12v北浮电池一个~#","permalink":"http://www.hikoyan.design/2020/06/post/","photos":[]},{"tags":[{"name":"Blender","slug":"Blender","permalink":"http://www.hikoyan.design/tags/Blender/"},{"name":"建模","slug":"建模","permalink":"http://www.hikoyan.design/tags/建模/"}],"title":"blender学习之路","text":"从如何编辑开始# 其实掌握一门建模软件并不是难事，都是对一个应用的熟悉到熟练的过程吧（虽然我可能没资格说这话） blender的三种编辑模式比较不一样（有可能是因为我建模入门是从最简单的SU开始的，对这个有些膈应） https://docs.blender.org/manual/zh-hans/2.80/modeling/meshes/structure.html blender的中文手册 感谢翻译~ 三个(三角面)，四个(四边面)或更多(n边面)顶点之间的区域定义为面，每侧都有一条边，通常缩写为 tris，quads ＆ n-gons。 三角形总是平坦的，因此易于计算。另一方面，四边形 “利于形变”，因此常用于动画和细分建模。 网格是3D场景中使用的常见物体类型。Blender配有一些 “基本” 网格形状，用户可以之为起点开始建模。编辑模式下，可以在3D游标位置添加基本体。 这个3D游标一开始使用起来真的很苦恼，尤其是Move的快捷键是G ，我实在不明白为什么是G 而且考虑到快捷键M应该有对应的了（有些教程也不改快捷键）所以就也没有去自定义。 重要的是blender建模有三种模式，热键分别对应1,2,3（shift多选 ctrl缩减或扩展选择),这个和其他的类似但是实际操作起来有点累（swtcl) 顶点模式下顶点会被显示为点。选中的顶点显示为橙色，未选中的顶点显示为黑色，当前活动的顶点或最后选择的顶点显示为白色。 边模式下顶点不显示。 不同的是，选中的边显示为橙色，未选中的边显示为黑色，当前活动的边或最后选择的边显示为白色。 面模式 面将伴随着一个用于对面进行选择的选择点在其中央进行显示。 选中的面及其选择点显示为橙色，未选中的面显示为黑色，当前激活的面或最后选择的面呈现白色高亮状态。 对我来说面模式是最接近SU操作的一个了 所以我经常在边模式和面模式中反复切换（ 按下dele键的时候可以选择删除的内容（还有其他操作） 刷选前在右侧属性设置好刷子的半径 配合shift ctrl就可以快速选面了 加/减选 扩展选区 Ctrl-数字键盘+ 扩展到当前选择模式下与选中区域相连的区域。 缩减选区 Ctrl-数字键盘- 从当前选择模式下选中区域相连的部分缩减选择。 下一活动元素 Shift-Ctrl-数字键盘+ 该功能利用了选择历史来基于环绕拓扑对下一个顶点、边、面进行选择。 上一活动元素 Shift-Ctrl-数字键盘- 选择前一活动元素并取消对最后选择元素的选择状态。","permalink":"http://www.hikoyan.design/2020/05/post/","photos":[]},{"tags":[{"name":"MySql","slug":"MySql","permalink":"http://www.hikoyan.design/tags/MySql/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.hikoyan.design/tags/Ubuntu/"},{"name":"Git","slug":"Git","permalink":"http://www.hikoyan.design/tags/Git/"}],"title":"这就是个笔记汇总啦","text":"[TOC] Ubuntu指令 LIst 常用指令 Notes 常用 Git 命令 1.新建代码库 2.配置 3.增删改 4.分支 5.标签tag 6.变化历史查询 MYSQL 创建数据库 4.2 显示数据库 4.3 删除数据库 4.4 连接数据库 4.5 当前选择的数据库 5.1 创建数据表 5.3 删除数据表 5.4 表插入数据 5.5 查询表中的数据 5.6 删除表中数据 5.7 修改表中数据 5.8 增加字段 5.9 修改表名 6、备份数据库 7.1 一个建库和建表的实例1 7.2 一个建库和建表的实例2 Ubuntu指令 LIst#常用指令#1234567891011121314151617181920212223pwd 当前工作目录 pwdls 当前目录内容(list) lsmkdir 创建目录(makedir) mkdir bookscd 进入目录 cd bookstouch 生成空文件 touch book.txtecho 带内容的文件 echo &quot;内容&quot; &gt; book.txtcp 拷贝文件（copy） cp book.txt book.txt.bakrm 删除文件（remove） rm -r（删除所有文件）/-f（强制删除） book.txtrm -rf +foldername 删除文件夹 rmdir 删除空目录 rmdir 空目录mv 移动文件（move） mv 原文件 目标位置mv 重命名 mv a.txt b.txtfind 查找文件 find [指定目录] -name 文件名grep 查找指定文件里的内容 grep &quot;是否有包含内容&quot; book.txtwc 统计文本的行数字符数 wc book.txttree 树状目录 treeln 建立软链接（link） ln -s 目标目录 链接目录（快捷方式）cat 查看文件内容 cat book.txtmore 分页显示文件内容less 分页显示文件内容head 显示文本开头内容tail 显示文件内容结尾内容vim编辑器： ：wq保存并退出 ：q直接退出 ：/搜索+要搜寻的字符串 （按n 下一个匹配的字符 Notes#-s 是代号（symbolic）的意思 ln命令会保持每一处链接文件的同步性——不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又软链接和硬链接两种，软链接就是ln –s 它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln ，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 用ls察看一个目录时，发现有的文件后面有一个@的符号，那就是一个用ln命令生成的文件，用ls –l命令去察看，就可以看到显示的link的路径了。 将档案 yy 产生一个 symbolic link : zz ln -s yy zz 文件夹建立软链接（用绝对地址） ln -s 源地址 目的地 常用 Git 命令#1.新建代码库#12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2.配置# 12345678910&gt; # 显示当前的Git配置&gt; $ git config --list&gt; &gt; # 编辑Git配置文件&gt; $ git config -e [--global]&gt; &gt; # 设置提交代码时的用户信息&gt; $ git config [--global] user.name \"[name]\"&gt; $ git config [--global] user.email \"[email address]\"&gt; 3.增删改#123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 4.分支#123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 5.标签tag#1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 6.变化历史查询#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git fetch origin git reset –hard MYSQL 创建数据库#注意：创建数据库之前要先连接Mysql服务器 命令：create database &lt;数据库名&gt; 例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb; 例2：创建数据库并分配用户 ①CREATE DATABASE 数据库名; ②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’; ③SET PASSWORD FOR ‘数据库名‘@’localhost’ = OLD_PASSWORD(‘密码’); 依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。 4.2 显示数据库#命令：show databases （注意：最后有个s）mysql&gt; show databases; 注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明： 1、修改MYSQL的配置文件：my.ini里面修改default-character-set=gbk2、代码运行时修改： ①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk ②PHP代码：header(“Content-Type:text/html;charset=gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL mysql, char csname)；该函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。 4.3 删除数据库#命令：drop database &lt;数据库名&gt;例如：删除名为 xhkdb的数据库mysql&gt; drop database xhkdb; 例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist​ //发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec) 4.4 连接数据库#命令： use &lt;数据库名&gt; 例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb;屏幕提示：Database changed use 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor​ -&gt; WHERE author.editor_id = db2.editor.editor_id; USE语句被设立出来，用于与Sybase相兼容。 有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。 4.5 当前选择的数据库#命令：mysql&gt; select database(); MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？ 1.显示MYSQL的版本mysql&gt; select version();+———————–+| version() |+———————–+| 6.0.4-alpha-community |+———————–+1 row in set (0.02 sec) 显示当前时间mysql&gt; select now();+———————+| now() |+———————+| 2009-09-15 22:35:32 |+———————+1 row in set (0.04 sec) 显示年月日SELECT DAYOFMONTH(CURRENT_DATE);+————————–+| DAYOFMONTH(CURRENT_DATE) |+————————–+| 15 |+————————–+1 row in set (0.01 sec) SELECT MONTH(CURRENT_DATE);+———————+| MONTH(CURRENT_DATE) |+———————+| 9 |+———————+1 row in set (0.00 sec) SELECT YEAR(CURRENT_DATE);+——————–+| YEAR(CURRENT_DATE) |+——————–+| 2009 |+——————–+1 row in set (0.00 sec) 显示字符串mysql&gt; SELECT “welecome to my blog!”;+———————-+| welecome to my blog! |+———————-+| welecome to my blog! |+———————-+1 row in set (0.00 sec) 当计算器用select ((4 4) / 10 ) + 25;+———————-+| ((4 4) / 10 ) + 25 |+———————-+| 26.60 |+———————-+1 row in set (0.00 sec) 串接字符串select CONCAT(f_name, “ “, l_name)AS Namefrom employee_datawhere title = ‘Marketing Executive’;+—————+| Name |+—————+| Monica Sehgal || Hal Simlai || Joseph Irvine |+—————+3 rows in set (0.00 sec)注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列’CONCAT(f_name, “ “, l_name)’起了个假名。 5.1 创建数据表#命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 例如，建立一个名为MyClass的表， 字段名 数字类型 数据宽度 是否为空 是否主键 自动增加 默认值 id int 4 否 primary key auto_increment name char 20 否 sex int 4 否 0 degree double 16 是 mysql&gt; create table MyClass( > id int(4) not null primary key auto_increment , > name char(20) not null, > sex int(4) not null default ‘0’, > degree double(16,2)); 5.3 删除数据表#命令：drop table &lt;表名&gt; 例如：删除表名为 MyClass 的表 mysql&gt; drop table MyClass; DROP TABLE用于取消一个或多个表。您必须有每个表的DROP权限。所有的表数据和表定义会被取消，所以使用本语句要小心！ 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 RESTRICT和CASCADE可以使分区更容易。目前，RESTRICT和CASCADE不起作用。 5.4 表插入数据#命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] 例如：往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99， 编号为3 的名为Wang 的成绩为96.5。 mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59); 注意：insert into每次只能向表中插入一条记录。 5.5 查询表中的数据#1)、查询所有行命令： select &lt;字段1，字段2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;例如：查看表 MyClass 中所有数据 mysql&gt; select * from MyClass; 2）、查询前几行数据例如：查看表 MyClass 中前2行数据mysql&gt; select * from MyClass order by id limit 0,2; select一般配合where使用，以查询更精确更复杂的数据。 5.6 删除表中数据#命令：delete from 表名 where 表达式 例如：删除表 MyClass中编号为1 的记录 mysql&gt; delete from MyClass where id=1; 下面是一个删除数据前后表的对比。 FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 下面以PHP代码为例删除 “Persons” 表中所有 LastName=’Griffin’ 的记录： 123456789&lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;peter&quot;,&quot;abc123&quot;); if (!$con) &#123; die(&apos;Could not connect: &apos; . mysql_error()); &#125; mysql_select_db(&quot;my_db&quot;, $con); mysql_query(&quot;DELETE FROM Persons WHERE LastName=&apos;Griffin&apos;&quot;); mysql_close($con); ?&gt; 在这次删除之后，表是这样的： FirstName LastName Age Glenn Quagmire 33 5.7 修改表中数据#语法：update 表名 set 字段=新值,… where 条件 mysql&gt; update MyClass set name=’Mary’ where id=1; 例子1：单表的MySQL UPDATE语句： UPDATE [LOW_PRIORITY][IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] [ORDER BY …][LIMIT row_count] 例子2：多表的UPDATE语句：UPDATE [LOW_PRIORITY][IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 …][WHERE where_definition] UPDATE语法可以用新值更新原有表行中的各列。SET子句指示要修改哪些列和要给予哪些值。WHERE子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。如果指定了ORDER BY子句，则按照被指定的顺序对行进行更新。LIMIT子句用于给定一个限值，限制可以被更新的行的数目。 5.8 增加字段#命令：alter table 表名 add字段 类型 其他;例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0 mysql&gt; alter table MyClass add passtest int(4) default ‘0’ 加索引 mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]);例子： mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引 mysql&gt; alter table 表名 add primary key (字段名);例子： mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table 表名 add unique 索引名 (字段名);例子： mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引 mysql&gt; alter table 表名 drop index 索引名;例子： mysql&gt;alter table employee drop index emp_name; 增加字段：mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型：mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段：MySQL ALTER TABLE table_name DROP field_name; 5.9 修改表名#命令：rename table 原表名 to 新表名; 例如：在表MyClass名字更改为YouClass mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 6、备份数据库#命令在DOS的[url=file://\\mysql\\bin]\\mysql\\bin[/url]目录下执行 1.导出整个数据库导出文件默认是存在mysql\\bin目录下​ mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名​ mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表​ mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名​ mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构​ mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql​ -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出​ mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa 7.1 一个建库和建表的实例1#drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘深圳’,​ year date); //建表结束 //以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令：​ mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 7.2 一个建库和建表的实例2#drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(​ id int(3) auto_increment not null primary key,​ name char(10) not null,​ address varchar(50) default ‘’深圳’’,​ year date); //建表结束 //以下为插入字段insert into teacher values(‘’’’,’’glchengang’’,’’深圳一中’’,’’1976-10-10’’);insert into teacher values(‘’’’,’’jack’’,’’深圳一中’’,’’1975-12-23’’); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。","permalink":"http://www.hikoyan.design/2019/23/2-23/","photos":[]},{"tags":[{"name":"Hiko","slug":"Hiko","permalink":"http://www.hikoyan.design/tags/Hiko/"}],"title":"Hiko'Blog (^_-)","text":"Welcome ! 终于在情人节这天把所有的博客需要的配置啊、搞坏掉的自己的仓库和在返校前想边改代码shit山边吃掉的小零食都准备完毕了，✿✿ヽ(°▽°)ノ✿ 整理一下这几天的成果大概就是，学会了各种编辑器、mysql等等命令行中如何退出的方法，靠着东撞西撞瞎搞乱搞的摸鱼方式弄好了这个博客（完全没弄好）。总之 简单md一些可能以后也需要回过头来咀嚼的知♂识，顺便充实首页头版文章（看上去很丰富的样子），毕竟平时不怎么习惯网上分享什么心得什么感悟，要写的话就长篇大论还会陷入丧气的咸鱼状态就，不了不了。 首先是买的辣鸡腾讯的服务器，一开始装了centos，啊然后因为学习后续内容的时候要康教程啊，教程都是apt-get，虽然也有很多yum的……反正就是为了一致（放弃思考）就干脆从控制台那重装了系统。诶装LNMP的时候其实，虽然看到有一键脚本但是…（种种原因一切都手动配置了 大概花了两三天吧 25 X 3 hours)。手动配置的过程 其实很有意思，一开始接触vim的时候，诶第一次vim file 可能手抖打错文件名了，是个新文件，瞬间一脸懵也不知道怎么退出（虽然百度得到可是，我不知道要搜vim编辑器 我以为是突然什么东西…），还在insert的状态下打了：wq就很气了。 装php的时候，因为php更新了，但是2018年的教程仍然是php7.0，所以修改文件的时候经常找不到conf，然后一点点cd ..才发现 文件夹都 只有一个7.2 算了都是些沙雕操作。 mysql的一键安装似乎是没有给root加密码的，我记得我设过啊？反正直接重新创了一个blog用户 sudo进去给它加了权限，把时间花在这些上确实有点浪费，却也算是学到很多了。 接下来是1 修改PHP 登录注册的安全性问题还没好好做完呢，虽然hexo提供了插件，应该可以直接用多说之类的，一想到这好歹算是个必修能力，还是老老实实借了本书回来慢慢研究。2 页面美化 banner的图知道尺寸以后 打算去ai直接画一个自己的（弄完php还有时间的话） 虽然hexo的主页是↑←这样已经很不错的简约模板，出于学习的目的（而且也不是很明白ejs） 在留言板的页面中skip_layout了，嘛还有很多要做。 大年初十过得这么有意义真是よかった。","permalink":"http://www.hikoyan.design/2019/04/hello-world/","photos":[]}]}